// * Implementation of montgomery ladder for curve25519

param rem_p : u64; /* 2^(4*64) mod p      */

// ** addition
// ************************************************************************

fn add(x : reg u64[4], ya : stack u64[4]) -> reg u64[4] {

  y          : reg u64[4];
  add0, add1 : reg u64;
  cf         : reg bool;
  i          : inline u64;

  for i in 0..4 {
    y[i] = ya[i];
    if   (i = 0) { cf, x[0] += y[0]; }
    else         { cf, x[i] += y[i] + cf; }
  }

  add0 = 0;
  add1 = $rem_p;
  add1 = add0 if !cf;

  for i in  0..4 {
    if (i = 0) {
      cf, x[0] += add1;
    } else {
      cf, x[i] += add0 + cf;
    }
  }

  add0 = add1 if cf;
  x[0] += add0;

  return x;
}

// ** subtraction
// ************************************************************************

fn sub(x : reg u64[4], ya : stack u64[4]) -> reg u64[4] {

  y          : reg u64[4];
  sub0, sub1 : reg u64;
  cf         : reg bool;
  i          : inline u64;

  for i in  0..4 {
    y[i] = ya[i];
    if (i = 0) {
      cf, x[0] -= y[0];
    } else {
      cf, x[i] -= y[i] - cf;
    }
  }

  sub0  = 0;
  sub1 = $rem_p;
  sub1 = sub0 if !cf;

  for i in  0..4 {
    if (i = 0) {
      cf, x[0] -= sub1;
    } else {
      cf, x[i] -= sub0 - cf;
    }
  }

  sub0 = sub1 if cf;
  x[0] -= sub0;

  return x;
}

// ** reduction from 8 limbs to 4 limbs
// ************************************************************************

fn reduce(z_in : reg u64[8]) -> reg u64[4] {
  crem_p, rax, l, h, hprev, zero : reg u64;
  z                              : reg u64[8];
  z_out                          : reg u64[4];
  cf                             : reg bool;
  i                              : inline u64;

  // FIXME: check if this is really required 
  for i in 0..8 { z[i] = z_in[i]; }

  crem_p = $rem_p;
  for i in 0..4 {
    rax = z[4 + i];
    h, l = rax * crem_p;
    cf, z[i] += l;
    if (i = 0) {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf, z[i] += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * $rem_p;
  cf, z[0] += l;

  for i in 1..4 {
    cf, z[i] += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * $rem_p;
  z[0] += l;

  // FIXME: check if this is really required 
  for i in 0..4 { z_out[i] = z[i]; }

  return z_out;
}

// ** multiplication
// ************************************************************************

fn mul(xa, ya : stack u64[4]) -> reg u64[4] {

  z           : reg u64[8];
  r           : reg u64[4];
  x, y        : reg u64[4];
  h, l, hprev : reg u64;
  cf          : reg bool;
  i, j        : inline u64;

  x[0] = xa[0];
  for j in 0..4 {
    y[j] = ya[j];
    h, l = y[j] * x[0];

    if (j = 0) {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      z[j + 1] = 0;
      z[j + 1] += h + cf;
    }
  }

  for i in 1..4 {
    x[i] = xa[i];
    for j in 0..4 {
      y[j] = ya[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if (j = 0) {
        hprev = 0;
        hprev += h + cf;
      } else {
        h += 0 + cf;
        cf, z[i+j] += hprev;
        if (1 <= j && j < 4 - 1) {
          hprev = 0;
          hprev += h + cf;
        } else { /* j = 4 */
          z[i + j + 1] = 0;
          cf, z[i + j + 1] += h + cf;
        }
      }
    }
  }

  r = reduce(z);

  //for i in 0..4 { r[i] = z[i]; }
  return r;
}

// ** squaring
// ************************************************************************

fn square(xa : stack u64[4]) -> reg u64[4] {

  z        : reg u64[8];
  r        : reg u64[4];
  t        : reg u64[5];
  rax, rdx : reg u64;
  cf       : reg bool;

  z[7] = 0;

  /*   2*x01 + 2*x02 + 2*x03 + 2*x12 + 2*x13 + 2*x23
     + x00 + x11 + x22 + x33 */

  rax = xa[1];
  rdx, rax = rax * xa[0];
  z[1] = rax;
  z[2] = rdx;

  rax = xa[2];
  rdx, rax = rax * xa[1];
  z[3] = rax;
  z[4] = rdx;

  rax = xa[3];
  rdx, rax = rax * xa[2];
  z[5] = rax;
  z[6] = rdx;

  /*   [2*]x01 + 2*x02 + 2*x03 + [2*]x12 + 2*x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xa[2];
  rdx, rax = rax * xa[0];
  cf, z[2] += rax;
  cf, z[3] += rdx + cf;
      z[4] += 0   + cf;

  rax = xa[3];
  rdx, rax = rax * xa[1];
  cf, z[4] += rax;
  cf, z[5] += rdx + cf;
      z[6] += 0   + cf;

  /*   [2*]x01 + [2*]x02 + 2*x03 + [2*]x12 + [2*]x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xa[3];
  rdx, rax = rax * xa[0];
  cf, z[3] += rax;
  cf, z[4] += rdx + cf;
  cf, z[5] += 0   + cf;
      z[6] += 0   + cf;

  /*   x01 + x02 + x03 + x12 + x13 + x23
     + x00 + x11 + x22 + x33 */

  /* set z<1..2n+1> = 2*z<1..2n+1> since
     we have summed all x_i*x_j with i<>j
     so far and these occur twice */
  cf, z[1] += z[1];
  cf, z[2] += z[2] + cf;
  cf, z[3] += z[3] + cf;
  cf, z[4] += z[4] + cf;
  cf, z[5] += z[5] + cf;
  cf, z[6] += z[6] + cf;
  cf, z[7] += z[7] + cf;

  /* x00 + x11 + x22 + x33 */

  rax = xa[0];
  rdx, rax = rax * xa[0];
  z[0] = rax;
  t[0] = rdx;

  rax = xa[1];
  rdx, rax = rax * xa[1];
  t[1] = rax;
  t[2] = rdx;

  rax = xa[2];
  rdx, rax = rax * xa[2];
  t[3] = rax;
  t[4] = rdx;

  cf, z[1] += t[0];
  cf, z[2] += t[1] + cf;
  cf, z[3] += t[2] + cf;
  cf, z[4] += t[3] + cf;
  cf, z[5] += t[4] + cf;
  cf, z[6] += 0 + cf;
      z[7] += 0 + cf;

  rax = xa[3];
  rdx, rax = rax * xa[3];
  cf, z[6] += rax;
      z[7] += rdx + cf;

  r = reduce(z);

  // FIXME: maybe an equality constraint is enough here
  //for i in 0..4 { r[i] = z[i]; }

  return r;
}

// ** ladderstep
// ************************************************************************

fn ladderstep(x1p, x2p, z2p, x3p, z3p : stack u64[4])
    -> stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] {

  t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8 : reg u64[4];
  t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p    : stack u64[4];
  w1, w2, w3, w4, w5, w6, w7                : reg u64[4];
  c121666p                                  : stack u64[4];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;

  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1      = x2p;
  t2      = t1;
  t1      = add(t1,z2p);
  t2      = sub(t2,z2p);
  t1p     = t1;
  t2p     = t2;
  t7      = square(t2p);
  t7p     = t7;
  t6      = square(t1p);
  t6p     = t6;
  t5      = t6;
  t5      = sub(t5,t7p);
  t5p     = t5;
  t3      = x3p;
  t4      = t3;
  t3      = add(t3,z3p);
  t4      = sub(t4,z3p);
  t3p     = t3;
  t4p     = t4;
  t9      = mul(t3p,t2p);
  t9p     = t9;
  t8      = mul(t4p,t1p);
  w1      = t8;
  w1      = add(w1,t9p);

  t8      = sub(t8,t9p);
  x3p     = w1;
  z3p     = t8;
  w2      = square(x3p);
  x3p     = w2;
  w3      = square(z3p);
  z3p     = w3;
  w4      = mul(z3p,x1p);
  z3p     = w4;
  w5      = mul(t6p,t7p);
  x2p     = w5;
  w6      = mul(t5p,c121666p);
  w6      = add(w6,t7p);
  z2p     = w6;
  w7      = mul(z2p,t5p);
  z2p     = w7;

  return x2p, z2p, x3p, z3p;
}

// ** ladderstep (tracing version for debugging)
// ************************************************************************


fn ladderstep_tracing(
    x1p, x2p, z2p, x3p, z3p : stack u64[4]
  ) -> stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] *
       stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] *
       stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] *
       stack u64[4] * stack u64[4] * stack u64[4]
 {

  t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8                      : reg u64[4];
  t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p                         : stack u64[4];
  w1, w2, w3, w4, w5, w6, w7                                     : reg u64[4];
  c121666p                                                       : stack u64[4];
  l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : stack u64[4];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;

  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1  = x2p;
  t2  = t1;
  t1  = add(t1,z2p);       l1 = t1;
  t2  = sub(t2,z2p);       l2 = t2;
  t1p = t1;
  t2p = t2;
  t7  = square(t2p);       l3 = t7;
  t7p = t7;
  t6  = square(t1p);       l4 = t6;
  t6p = t6;
  t5  = t6;
  t5  = sub(t5,t7p);       l5 = t5;
  t5p = t5;
  t3  = x3p;
  t4  = t3;
  t3  = add(t3,z3p);       l6 = t3;
  t4  = sub(t4,z3p);       l7 = t4;
  t3p = t3;
  t4p = t4;
  t9  = mul(t3p,t2p);      l8 = t9;
  t9p = t9;
  t8  = mul(t4p,t1p);      l9 = t8;
  w1  = t8;
  w1  = add(w1,t9p);       l10 = w1;

  t8  = sub(t8,t9p);       l11 = t8;
  x3p = w1;
  z3p = t8;
  w2  = square(x3p);       l12 = w2;
  x3p = w2;
  w3  = square(z3p);       l13 = w3;
  z3p = w3;
  w4  = mul(z3p,x1p);      l14 = w4;
  z3p = w4;
  w5  = mul(t6p,t7p);      l15 = w5;
  x2p = w5;
  w6  = mul(t5p,c121666p); l16 = w6;
  w6  = add(w6,t7p);       l17 = w6;
  z2p = w6;
  w7  = mul(z2p,t5p);      l18 = w7;
  z2p = w7;

  return l1,  l2, l3,   l4,  l5,
         l6,  l7, l8,   l9,  l10,
         l11, l12, l13, l14, l15,
         l16, l17, l18;
}

// ** cswap
// ************************************************************************

// FIXME: compare with OpenSSL, this is a translation from C
fn cswap(x2p, z2p, x3p, z3p : stack u64[4], swap : reg u64)
    -> stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] {

  tmp1, tmp2, mask : reg u64;
  i                : inline u64;

  mask = swap * 0xffff_ffff_ffff_ffff;

  for i in 0..4 {
    tmp1   = x2p[i];
    tmp1  ^= x3p[i];
    tmp1  &= mask;
    tmp2   = x2p[i];
    tmp2  ^= tmp1;
    x2p[i] = tmp2;

    tmp2   = x3p[i];
    tmp2  ^= tmp1;
    x3p[i] = tmp2;

    tmp1   = z2p[i];
    tmp1  ^= z3p[i];
    tmp1  &= mask;
    tmp2   = z2p[i];
    tmp2  ^= tmp1;
    z2p[i] = tmp2;
    tmp2   = z3p[i];
    tmp2  ^= tmp1;
    z3p[i] = tmp2;
  }
  return x2p, z2p, x3p, z3p;
}

// ** montgomery ladder
// ************************************************************************

fn mladder(xr, sp : stack u64[4]) -> stack u64[4] * stack u64[4] {

  s                     : stack u64;
  tmp1, tmp2, bit, swap : reg u64;
  prevbit               : stack u64;
  x1,x2,z2,x3,z3        : stack u64[4];
  i, j                  : reg u64;
  i_s, j_s              : stack u64; // store values on stack
  cf                    : reg bool;

  prevbit = 0;
  x1 = xr;
  x2[0] = 1; x2[1] = 0; x2[2] = 0; x2[3] = 0;
  z2[0] = 0; z2[1] = 0; z2[2] = 0; z2[3] = 0;
  x3 = xr;
  z3[0] = 1; z3[1] = 0; z3[2] = 0; z3[3] = 0;

  i = 3;
  do {
    tmp1 = sp[i];
    i_s = i; // probably need the register
    s = tmp1;
    j = 63;
    do {
      tmp2 = s;
      bit = tmp2 >> j;
      j_s = j; // probably need the register
      bit = bit & 1;
      swap = prevbit;
      swap ^= bit;
      prevbit = bit;
      x2,z2,x3,z3 = cswap(x2,z2,x3,z3,swap);
      x2,z2,x3,z3 = ladderstep(x1,x2,z2,x3,z3);
      j = j_s;
      cf,j -= 1;  // returns cf=1 for input j=0
    } while !cf;
    i = i_s;
    cf,i -= 1; // returns cf=1 for input i=0
  } while !cf;
  swap = prevbit;
  x2,z2,x3,z3 = cswap(x2,z2,x3,z3,swap);
  return x2, z2;
}

// ** inversion
// ************************************************************************

fn squarea(x : stack u64[4]) -> stack u64[4] {
  r  : reg u64[4];
  ra : stack u64[4];

  r = square(x);
  ra = r;
  return ra;
}

fn mula(x, y : stack u64[4]) -> stack u64[4] {
  r  : reg u64[4];
  ra : stack u64[4];

  r = mul(x,y);
  ra = r;
  return ra;
}

fn invert(xa : stack u64[4]) -> stack u64[4] {
  ra, z2, t, z9, z11, z2_5_0, z2_10_0, z2_20_0, z2_50_0 : stack u64[4];
  z2_100_0                                              : stack u64[4];
  i                                                     : inline u64;

  z2 = squarea(xa);                   /* 2 */
  t = squarea(z2);                    /* 4 */
  t = squarea(t);                     /* 8 */
  z9 = mula(t,xa);                    /* 9 */
  z11 = mula(z9,z2);                  /* 11 */
  t = squarea(z11);                   /* 22 */
  z2_5_0 = mula(t,z9);                /* 2^5 - 2^0 = 31 */

  t = squarea(z2_5_0);                /* 2^6 - 2^1 */
  for i in 1..5 { t = squarea(t); }   /* 2^20 - 2^10 */
  z2_10_0 = mula(t,z2_5_0);           /* 2^10 - 2^0 */

  t = squarea(z2_10_0);               /* 2^11 - 2^1 */
  for i in 1..10 { t = squarea(t); }  /* 2^20 - 2^10 */
  z2_20_0 = mula(t,z2_10_0);          /* 2^20 - 2^0 */

  t = squarea(z2_20_0);               /* 2^21 - 2^1 */
  for i in 1..20 { t = squarea(t); }  /* 2^40 - 2^20 */
  t = mula(t,z2_20_0);                /* 2^40 - 2^0 */

  t = squarea(t);                     /* 2^41 - 2^1 */
  for i in 1..10 { t = squarea(t); }  /* 2^50 - 2^10 */
  z2_50_0 = mula(t,z2_10_0);          /* 2^50 - 2^0 */

  t = squarea(z2_50_0);               /* 2^51 - 2^1 */
  for i in 1..50 { t = squarea(t); }  /* 2^100 - 2^50 */
  z2_100_0 = mula(t,z2_50_0);         /* 2^100 - 2^0 */

  t= squarea(z2_100_0);               /* 2^101 - 2^1 */
  for i in 1..100 { t = squarea(t); } /* 2^200 - 2^100 */
  t = mula(t,z2_100_0);               /* 2^200 - 2^0 */

  t = squarea(t);                     /* 2^201 - 2^1 */
  for i in 1..50 { t = squarea(t); }  /* 2^250 - 2^50 */
  t = mula(t,z2_50_0);                /* 2^250 - 2^0 */

  t = squarea(t);                     /* 2^251 - 2^1 */
  t = squarea(t);                     /* 2^252 - 2^2 */
  t = squarea(t);                     /* 2^253 - 2^3 */

  t = squarea(t);                     /* 2^254 - 2^4 */

  t = squarea(t);                     /* 2^255 - 2^5 */
  ra = mula(t,z11);                   /* 2^255 - 21 */

  return ra;
}

// ** unpack_point
// ************************************************************************

fn unpack_point(xp : reg u64) -> stack u64[4] {
  xa : stack u64[4];
  x3 : reg u64;

  xa[0] = MEM[xp + 0*8];
  xa[1] = MEM[xp + 1*8];
  xa[2] = MEM[xp + 2*8];
  x3    = MEM[xp + 3*8];
  x3    = x3 & 0x7fff_ffff_ffff_ffff;
  xa[3] = x3;

  return xa;
}

// ** unpack_secret
// ************************************************************************

fn unpack_secret(sp : reg u64) -> stack u64[4] {
  sa : stack u64[4];
  si : reg u64;

  si    = MEM[sp + 0*8];
  si    = si & 0xffff_ffff_ffff_fff8;
  sa[0] = si;
  sa[1] = MEM[sp + 1*8];
  sa[2] = MEM[sp + 2*8];
  si    = MEM[sp + 3*8];
  si    = si & 0x7fff_ffff_ffff_ffff;
  si    = si | 0x4000_0000_0000_0000;
  sa[3] = si;
  return sa;
}

// ** freeze
// ************************************************************************

fn freeze(xa : reg u64[4]) -> reg u64[4] {
  r, t  : reg u64[4];
  two63 : reg u64;
  cf    : reg bool;

  r = xa;
  t = r;
  two63 = 1;
  two63 <<= 63;
  cf, t[0] += 19;
  cf, t[1] += 0     + cf;
  cf, t[2] += 0     + cf;
  cf, t[3] += two63 + cf;
  r[0] = t[0] if cf;
  r[1] = t[1] if cf;
  r[2] = t[2] if cf;
  r[3] = t[3] if cf;
  t[0] = r[0];
  t[1] = r[1];
  t[2] = r[2];
  t[3] = r[3];
  cf, t[0] += 19;
  cf, t[1] += 0     + cf;
  cf, t[2] += 0     + cf;
  cf, t[3] += two63 + cf;
  r[0] = t[0] if cf;
  r[1] = t[1] if cf;
  r[2] = t[2] if cf;
  r[3] = t[3] if cf;
  xa[0] = r[0];
  xa[1] = r[1];
  xa[2] = r[2];
  xa[3] = r[3];
  return xa;
}

// ** pack
// ************************************************************************

/* assumes input x reduced below 2^255 */
fn pack(rp : reg u64, xa : reg u64[4]) {
  i : inline u64;

  xa = freeze(xa);
  for i in 0..4 {
    MEM[rp + (i*8)] = xa[i];
  }
}

// ** scalar multiplication
// ************************************************************************

extern fn scalarmult( rp : reg u64 /* address to store result  */
                    , sp : reg u64 /* address of secret scalar */
                    , pp : reg u64 /* address of point         */) {
  sa, xa, za, zia : stack u64[4];
  rp_s            : stack u64;
  r               : reg u64[4];

  rp_s = rp; // FIXME: really required?
  sa = unpack_secret(sp);
  xa = unpack_point(pp);
  xa, za = mladder(xa,sa);
  zia = invert(za);
  r = mul(xa,zia);
  rp = rp_s;
  pack(rp,r);
}

fn scalarmult_tracing(
      rp : reg u64 /* address to store result  */
    , sp : reg u64 /* address of secret scalar */
    , pp : reg u64 /* address of point         */)
  -> stack u64[4] * stack u64[4] * stack u64[4] *
     stack u64[4] * stack u64[4] * stack u64[4]
{
  sa, xa, za, zia   : stack u64[4];
  l1,l2,l3,l4,l5,l6 : stack u64[4];
  r                 : reg u64[4];

  sa = unpack_secret(sp);       l1 = sa;
  xa = unpack_point(pp);        l2 = xa;
  xa, za = mladder(xa,sa);      l3 = xa; l4 = za;
  zia = invert(za);             l5 = zia;
  r = mul(xa,zia);              l6 = r;
  pack(rp,r);
  return l1,l2,l3,l4,l5,l6;
}

// * tests
// ************************************************************************

fn rand_arr(stack u64) -> stack u64[4] = python rand;
fn rand_point(stack u64) -> stack u64[4] = python rand_point;
fn assert_equal(x,y : stack u64[4]) = python assert_equal;
fn print_arr(x : stack u64[4]) = python print_u64_arr;
fn print_u64(x : stack u64) = python print_u64;
fn print_newline() = python print_newline;
fn assert_equal_add(x,y,z : stack u64[4]) = python assert_equal_add;
fn assert_equal_sub(x,y,z : stack u64[4]) = python assert_equal_sub;
fn assert_equal_mul(x,y,z : stack u64[4]) = python assert_equal_mul;
fn assert_equal_arr(x,y : stack u64[4]) = python assert_equal_arr;
fn assert_equal_ladderstep(x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r : stack u64[4])
  = python assert_equal_ladderstep;
fn assert_equal_ladderstep_tracing(x1,x2,z2,x3,z3
     ,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : stack u64[4])
  = python assert_equal_ladderstep_tracing;
fn assert_equal_mladder(xr, sp, xr_r, zr_r : stack u64[4]) = python assert_equal_mladder;
fn assert_equal_scalarmult(r, p, s : stack u64[4]) = python assert_equal_scalarmult;
fn assert_equal_scalarmult_tracing(r,p,s,l1,l2,l3,l4,l5,l6 : stack u64[4])
  = python assert_equal_scalarmult_tracing;
fn assert_equal_inv(x, y : stack u64[4]) = python assert_equal_inv;
fn mod_p(s : stack u64[4]) -> stack u64[4] = python mod_p;

fn test_add() {
  x, y_tmp, z : stack u64[4];
  y           : stack u64[4];
  u           : stack u64;
  i           : inline u64;
  x_r, z_r    : reg u64[4];

  for i in 0..999 {
    u = i;
    print_u64(u);
    x = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    y = y_tmp;
    x_r = x;
    z_r = add(x_r,y);
    z = z_r;
    assert_equal_add(x,y,z);
  }
}

fn test_sub() {
  x, y_tmp, z : stack u64[4];
  x_r, z_r    : reg u64[4];
  y           : stack u64[4];
  u           : stack u64;
  i           : inline u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    y = y_tmp;
    x_r = x;
    z_r = sub(x_r,y);
    z = z_r;
    assert_equal_sub(x,y,z);
  }
}

fn test_mul() {
  x_tmp, y_tmp, z : stack u64[4];
  x, y            : stack u64[4];
  z_r             : reg u64[4];
  u               : stack u64;
  i               : inline u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x_tmp = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    x = x_tmp;
    y = y_tmp;
    z_r = mul(x,y);
    z = z_r;
    assert_equal_mul(x,y,z);
  }
}

fn test_square() {
  x_tmp, z : stack u64[4];
  x        : stack u64[4];
  u        : stack u64;
  i        : inline u64;
  z_r      : reg u64[4];

  for i in 0..999 {
    u = i;
    print_u64(u);
    x_tmp = rand_arr(u);
    x = x_tmp;
    z_r = square(x);
    z = z_r;
    assert_equal_mul(x,x,z);
  }
}

fn test_ladderstep() {
  u                       : stack u64;
  x1, x2, z2, x3, z3      : stack u64[4];
  x2_r, z2_r, x3_r, z3_r  : stack u64[4];
  i                       : inline u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x1 = rand_arr(u); u += 1;
    x2 = rand_arr(u); u += 1;
    z2 = rand_arr(u); u += 1;
    x3 = rand_arr(u); u += 1;
    z3 = rand_arr(u); u += 1;

    x2_r,z2_r,x3_r,z3_r = ladderstep(x1,x2,z2,x3,z3);
    assert_equal_ladderstep(x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r);
  }
}

fn test_ladderstep_tracing() {
  u                               : stack u64;
  x1, x2, z2, x3, z3              : stack u64[4];
  l1,l2,l3,l4,l5,l6,l7,l8,l9,l10  : stack u64[4];
  l11,l12,l13,l14,l15,l16,l17,l18 : stack u64[4];
  i                               : inline u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x1 = rand_arr(u); u += 1;
    x2 = rand_arr(u); u += 1;
    z2 = rand_arr(u); u += 1;
    x3 = rand_arr(u); u += 1;
    z3 = rand_arr(u); u += 1;

    l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18
      = ladderstep_tracing(x1,x2,z2,x3,z3);
    assert_equal_ladderstep_tracing(x1, x2, z2, x3, z3,
      l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18);
  }
}

fn test_swap() {
  x2r, z2r, x3r, z3r         : stack u64[4];
  x2r_a, z2r_a, x3r_a, z3r_a : stack u64[4];
  x2r_b, z2r_b, x3r_b, z3r_b : stack u64[4];
  u                          : stack u64;
  zero                       : reg u64;
  one                        : reg u64;
  i                          : inline u64;

  zero = 0;
  one = 1;
  for i in 0..999 {
    u = i;
    print_u64(u);
    x2r = rand_arr(u); u += 1;
    z2r = rand_arr(u); u += 1;
    x3r = rand_arr(u); u += 1;
    z3r = rand_arr(u); u += 1;
    x2r_a, z2r_a, x3r_a, z3r_a = cswap(x2r,z2r,x3r,z3r,zero);
    x2r_b, z2r_b, x3r_b, z3r_b = cswap(x2r,z2r,x3r,z3r,one);

    assert_equal_arr(x2r, x2r_a);
    assert_equal_arr(z2r, z2r_a);
    assert_equal_arr(x3r, x3r_a);
    assert_equal_arr(z3r, z3r_a);

    assert_equal_arr(x2r, x3r_b);
    assert_equal_arr(z2r, z3r_b);
    assert_equal_arr(x3r, x2r_b);
    assert_equal_arr(z3r, z2r_b);
  }
}


fn test_mladder() {
  xr         : stack u64[4];
  xr_r, zr_r : stack u64[4];
  sp         : stack u64[4];
  u          : stack u64;
  i          : inline u64;

  sp[0] = 0xffff_ffff_ffff_ffff;
  sp[1] = 0;
  sp[2] = 0x5555_5555_5555_5555;
  sp[3] = 0xffff_ffff_ffff_fffe;
  for i in 0..99 {
    u = i;
    print_u64(u);
    xr = rand_arr(u); u += 1;
    xr_r, zr_r = mladder(xr,sp);
    assert_equal_mladder(xr,sp,xr_r,zr_r);
  }
}

fn test_scalarmult() {
  pa, sa, ra : stack u64[4];
  rp, sp,pp  : reg u64;
  u          : stack u64;
  i          : inline u64;

  rp = 0;
  sp = $(4*8); // 4*64bit = 4*8byte
  pp = $(8*8);

  for i in 0..99 {
    u = i;
    print_u64(u);
    pa = rand_point(u); u += 1;
    MEM[pp + 0*8] = pa[0];
    MEM[pp + 1*8] = pa[1];
    MEM[pp + 2*8] = pa[2];
    MEM[pp + 3*8] = pa[3];
    sa = rand_arr(u); u += 1;
    MEM[sp + 0*8] = sa[0];
    MEM[sp + 1*8] = sa[1];
    MEM[sp + 2*8] = sa[2];
    MEM[sp + 3*8] = sa[3];

    scalarmult(rp,sp,pp);
    //l1,l2,l3,l4,l5,l6 = scalarmult_tracing(rp,sp,pp);
    ra[0] = MEM[rp + 0*8];
    ra[1] = MEM[rp + 1*8];
    ra[2] = MEM[rp + 2*8];
    ra[3] = MEM[rp + 3*8];

    assert_equal_scalarmult(ra,pa,sa);
    //assert_equal_scalarmult_tracing(ra,pa,sa,l1,l2,l3,l4,l5,l6);
  }
}

fn test_full() {
  test_add();
  print_newline();
  test_sub();
  print_newline();
  test_mul();
  print_newline();
  test_square();
  print_newline();
  test_ladderstep_tracing();
  print_newline();
  test_ladderstep();
  print_newline();
  test_swap();
  print_newline();
  test_mladder();
  print_newline();
  test_scalarmult();
  print_newline();
}

fn test_fast() {
  test_mladder();
}

fn test() {
  test_full();
  //test_scalarmult();
  print_newline();
}
