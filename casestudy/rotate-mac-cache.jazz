inline fn rotate_mac_cache(reg u32 md_size, reg u32 rotate_offset, reg u64 out, reg u64 rotated_mac) {

  reg u32 i;
  reg u8 temp_8, temp2_8;
  reg u32 temp_32;
  reg u64 temp;
    // NOW rotate the mac
  i = 0;
  while (i < md_size) {
    // ((volatile unsigned char *)rotated_mac)[rotate_offset^32];
   /* This is necessary only if the cache line is 32.
      We do not use it in the current model. 
      Furthermore I suppect this is not correct if the cache line is 32 */

    temp_32 = rotate_offset;
    temp_32 ^= 32;
    temp = (64u) temp_32;
    temp_8 = (u8)[rotated_mac + temp];
    temp_8 ^= temp_8;

    // out[j++] = rotated_mac[rotate_offset++];
    temp = (64u) rotate_offset;
    temp_8 = (u8)[rotated_mac + temp];
    rotate_offset += 1;
    temp = (64u) i;
    (u8)[out + temp] = temp_8;

    // rotate_offset &= constant_time_lt(rotate_offset,md_size);
    temp_32 = 0;
    rotate_offset = temp_32 if md_size <= rotate_offset;
    //temp_32 = constant_time_lt_jasmin(rotate_offset, md_size);
    //temp = (64u) temp_32;
    //rotate_offset &= temp_32;
    i += 1;
  } 
}

inline
fn test_with_secret(reg u32 secret_offset) {
reg u64 out rotated_mac;
inline int i;
  out = 0x1000;
  rotated_mac = 0x2000;
  for i = 0 to 64 {
  // (u8)[out + i] = 0;
  (u8)[rotated_mac + i] = 0;
  }
rotate_mac_cache(
  64,
  secret_offset,
  out,
  rotated_mac
  );
}

inline fn test_31() { test_with_secret(31); }
inline fn test_63() { test_with_secret(63); }

exec test_31 test_63 (0x1000 : 64, 0x2000 : 64)

