inline fn opp_mod(reg u32 rotate_offset md_size) -> reg u32 {
  reg u32 temp, zero;

  zero = 0;
  temp = md_size;
  temp -= rotate_offset;
  rotate_offset = temp;
  rotate_offset = zero if rotate_offset == md_size;
  return rotate_offset;
}

inline fn rotate_mac_BL(reg u32 md_size rotate_offset, reg u64 out, stack u8[128] rotated_mac) {
  reg u64 i, j;
  reg u32 old, new, zero, temp;

  zero = 0;
  rotate_offset = opp_mod(rotate_offset, md_size);
  i = 0;
  while(i < md_size) {
     j = 0;
    while(j < md_size) {
      old = (32u)(u8)[out + j];
      new = (32u)rotated_mac[(int) i];
      new = old if j != rotate_offset;
      (u8)[out + j] = new;
      j += 1;
    }
    rotate_offset += 1;
    rotate_offset = zero if md_size <= rotate_offset;
    i += 1;
  }
}

inline fn rotate_mac_CL(reg u32 md_size rotate_offset, reg u64 out rotated_mac) {
  reg u8 new;
  reg u64 i, zero, ro;

  zero = 0;
  ro = (64u) rotate_offset;
  i = 0;
  while (i < md_size) {
    new = (u8)[rotated_mac + ro];
    (u8)[out + i] = new;
    ro += 1;
    ro = zero if md_size <= ro;
    i += 1;
  }
}

inline
fn test_with_secret_CL(reg u32 secret_offset) {
reg u64 out rotated_mac;
inline int i;
  out = 0x1000;
  rotated_mac = 0x2000;
  for i = 0 to 64 {
  // (u8)[out + i] = 0;
  (u8)[rotated_mac + i] = 0;
  }
rotate_mac_CL(
  64,
  secret_offset,
  out,
  rotated_mac
  );
}

inline
fn test_with_secret_BL(reg u32 secret_offset) {
reg u64 out;
stack u8[128] rotated_mac;
inline int i;
  out = 0x1000;
  for i = 0 to 64 {
  // (u8)[out + i] = 0;
  rotated_mac[(int)i] = 0;
  }
rotate_mac_BL(
  64,
  secret_offset,
  out,
  rotated_mac
  );
}

inline fn test_CL_31() { test_with_secret_CL(31); }
inline fn test_CL_63() { test_with_secret_CL(63); }

inline fn test_BL_31() { test_with_secret_BL(31); }
inline fn test_BL_63() { test_with_secret_BL(63); }

exec test_CL_31 test_CL_63 (0x1000 : 64, 0x2000 : 64)
exec test_BL_31 test_BL_63 (0x1000 : 64)