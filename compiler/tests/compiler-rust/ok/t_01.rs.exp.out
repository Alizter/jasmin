type checking module in all function(s)
   REMOVED_TIME

running 1 test
test test::test1 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

>> roundtrip:
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_assignments)]

#[macro_use] extern crate jasmin;

rust! {
    use jasmin::jasmin::*;
    use jasmin::U64::*;
    
}

rust! {
    mod test {
        use jasmin::jasmin::*;
        use jasmin::U64::*;

        #[test]
        fn test1() {
            ::foo3(0.to_jval());
        }
    }
}

rust! {
    fn foo1(x: stack! (b64)) -> (stack! (b64), reg! (b64), reg! (b1)) {
        return (x,x,jc!(false));
    }
}

const n : b64 = jc!(10);

decl! { fn foo1(stack! (b64)) -> (stack! (b64),reg! (b64),reg! (b1)); }
fn foo3(mut _x: stack! (b64)) {
}

pub fn foo4(mut _x: stack! (b64)) {
}

pub fn foo5(mut x: stack! (b64)) {
    code! {
        x = add(x,x);
    }
}

fn foo6(mut x: stack! (b64)) -> stack! (b64) {
    return x
}

fn foo7(mut x: stack! (b64)) {
    var! {
        y: stack! (b64);
    }
    code! {
        y = jc!(0);
        x = add(x,y);
    }
}

fn foo8(mut x: stack! (b64)) -> (stack! (b64),stack! (b64)) {
    return (x,x)
}

fn foo9(mut x: stack! (b64)) -> stack! (b64) {
    code! {
        x = add(x,x);
    }
    return x
}

fn foo10(mut x: stack! (b64), mut y: stack! (b64), mut z: reg! (b1)) -> stack! (b64) {
    var! {
        w: stack! (b64);
    }
    code! {
        w = x;
        (w,x,z) = foo1(x);
        inl!{ foo4(x) };
        x = jc!(5);
        w = add(w,x);
        if (w == jc!(5)) {
            (z,x) = add_cf(x,w);
            (z,x) = add_cf(x,y);
        }
        x = adc(x,x,z);
    }
    return x
}


total transformation time: REMOVED_TIME

total time (with save/print): REMOVED_TIME
