export
fn test_mem128(reg u64 p) {
reg u128 r;

r = (u128)[p + 16 * 0];
(u128)[p + 16 * 1] = r;
}

export
fn test_xor (reg u64 p) {
reg u128 r, s, t, u;
r = (u128)[p + 16 * 0];
s = (u128)[p + 16 * 1];
t = (u128)[p + 16 * 2];
u = (u128)[p + 16 * 3];

r ^= s;
r &= t;
r |= u;

(u128)[p + 16 * 1] = r;

}

export
fn test_add(reg u64 p) {
reg u128 r, s, t;

r = (u128)[p + 16 * 0];
s = (u128)[p + 16 * 1];

t = #x86_VPADD_8u16(r, s);
r = #x86_VPADD_4u32(s, t);
s = #x86_VPADD_2u64(t, r);

(u128)[p + 16 * 1] = s;
}

u128 rotate24pattern = 0x0c0f0e0d080b0a090407060500030201;

export
fn test_shuffle(reg u64 p) {
reg u128 r;
r = (u128)[p + 0];
r = #x86_VPSHUFB(r, rotate24pattern);
(u128)[p + 0] = r;
}

export
fn test_avx2(reg u64 p) {
reg u256 r, s, t, u, v;
r = (u256)[p + 0];
s = (u256)[p + 32];
t = (u256)[p + 64];
r = #x86_VPSHUFD_256(r, 0x33);
u = #x86_VPBLENDD_256(s, t, 0xa4);
v = r ^ u;
(u256)[p + 32] = v;
}

export
fn test_vpshuf(reg u64 p) {
reg u128 a, b;
reg u256 y, z;

a = (u128)[p + 0];
y = (u256)[p + 32];

b = #x86_VPSHUFLW(a, 7);
z = #x86_VPSHUFHW_256(y, 42);

(u128)[p + - 16] = b;
(u256)[p + 32] = z;
}
