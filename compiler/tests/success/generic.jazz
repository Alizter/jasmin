/*some toy code just to polish some ideias about generic code */

u64[6] g_P = {
   0xB9FEFFFFFFFFAAAB
  ,0x1EABFFFEB153FFFF
  ,0x6730D2A0F6B0F624
  ,0x64774B84F38512BF
  ,0x4B1BA7B6434BACD7
  ,0x1A0111EA397FE69A
};

// would it make sense to make the following function generic too?
// for now it stays as it is
fn _fp_addm_low(reg ptr u64[6] c a b) -> reg ptr u64[6] 
{
  inline int i;
  reg bool cf;
  reg u64[6] acc1 acc2;
  stack ptr u64[6] _c;

  _c = c;

  /* acc1 = a + b*/
  acc1[0] = a[0];
  cf, acc1[0] += b[0];
  for i = 1 to 6 {
    acc1[i] = a[i];
    cf, acc1[i] += b[i] + cf;
  }

  acc2 = acc1;

  /* acc2 -= P*/
  cf, acc2[0] -= g_P[0];
  for i = 1 to 6 {
    cf, acc2[i] -= g_P[i] - cf;
  }

  /* acc1 = acc2 if !cf*/
  for i = 0 to 6 {
    acc1[i] = acc2[i] if !cf;
  }

  c = _c;
  c = acc1;

  return c;
}

/* and now we would like to have some generic code for extension fields: 
  instead of using global param int we could use param int as parameters 
  (and any use of this function would have to be inlined) */

inline fn __fpX_addm_low(param int X, reg ptr u64[6*X] c a b) -> reg ptr u64[6*X]
{
  inline int i;
  stack ptr u64[6*X] as bs;

  as = a; bs = b;
  for i=0 to X {
    a = as; b = bs;
    c[i*6:6] = _fp_addm_low(c[i*6:6], a[i*6:6], b[i*6:6]);
  }
  return c;
}

/* and now we could instantiate extension fields as: 
  (these could be macro generated so we would get them for free)*/
fn _fp2_addm_low(reg ptr u64[12] c a b) -> reg ptr u64[12]
{
  c = __fpX_addm_low(2, c, a, b);
  return c;
}

fn _fp2_addm_low_bis(reg ptr u64[12] c a b) -> reg ptr u64[12]
{
  c = __fpX_addm_low(2, c, a, b);
  return c;
}

fn _fp6_addm_low(reg ptr u64[36] c a b) -> reg ptr u64[36]
{
  c = __fpX_addm_low(6, c, a, b);
  return c;
}
