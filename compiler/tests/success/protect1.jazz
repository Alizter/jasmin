export fn foo (#public reg u64 i) -> reg u64 {
  #transient stack u64[1] p;
  #transient stack u64 si;
  #msf reg u64 ms;
  #transient reg u64 r;
  #public reg bool b;
  #transient reg u64 it;

  /* init miss-speculation flag / mask to 0 (ie no miss-speculation)
     This correspond to the sequence
     LFENCE;
     ms = 0;
  */
  ms = #init_msf();

  p[0] = 1;
  si = i; // spill i into si
  b = i == 0;
  if (b) {
     _, ms = #set_msf(b, ms);
     it = si;
     _, _, _, _, _, i = #protect(it, ms);
     r = p[(int)i];
  } else {
     _, ms = #set_msf(!b, ms);
     r = p[0];
  }
  ? #LFENCE;
  return r;
}

inline fn test1(#poly=l1 stack u64[1] x) -> #poly={transient, l1} reg u64 {
   #poly={transient, l1} reg u64 r;
   r = x[0];
   return r;
}

export fn test1_app_secret(#secret reg u64 x) {
   #secrect stack u64[1] s;
   s[0] = x;
   x = test1(s);
}

export fn test1_app_public(#public reg u64 x) {
   #transient stack u64[1] s;
   #transient reg u64 r;
   #msf reg u64 ms;
   s[0] = x;
   r = test1(s);
   ms = #init_msf();
   _, _, _, _, _, x = #protect(r, ms);
}

/* This should fail
export fn test1_app_fail(#public reg u64 x) {
   #transient stack u64[1] s;
   s[0] = x;
   x = test1(s);
}
*/



fn aux(#msf reg u64 ms, #public reg u64 p, #public reg u64 i) -> #msf reg u64, #public reg u64 {

   #public reg bool b;

   while
    {b = i < 0;}
    (b)
    { [p] = 0; p += 1; _, ms = #set_msf(b, ms); i -= 1; }
   _, ms = #set_msf(!b, ms);
   return (ms, p);

}

/* This loop, need to fix the case of while */

fn aux1(#msf reg u64 ms, #public reg u64 p, #public reg u64 i) -> #msf reg u64, #public reg u64 {

   #public reg bool b;

   while
    {b = i < 0;}
    (b)
    { [p] = 0; p += 1; i -= 1; }
   ms = #init_msf();
   return (ms, p);

}


fn sum_regptr(#msf reg u64 ms, #transient reg ptr u64[1000]p) -> #msf reg u64, #public reg u64 {

   #public reg bool b;
   #transient reg u64 sum;
   #public reg u64 psum, i;
   sum = 0;
   i = 0;
   while
    {b = i < 1000;}
    (b)
    { sum += p[(int)i] ; _, ms=#set_msf(b, ms); i += 1; }
   _, ms = #set_msf(!b, ms);
   _, _, _, _, _, psum = #protect(sum, ms);

   return (ms, psum);

}

#nomodmsf fn nomod() -> #public reg u64 {
   #public reg u64 r;
   r = 0;
   return r;
}

fn usenomod() -> #public reg u64 {
   #transient stack u64 s;
   #public reg u64 rp r;
   #transient reg u64 rt;
   #msf reg u64 ms;
   ms = #init_msf();
   s = 0;
   rt = s;
   r = nomod();
   _, _, _, _, _, rp = #protect(rt, ms);
   r += rp;
   [r] = 0;
   return r;
}

/*
#nomodmsf fn nomod_wrong(#public reg u64 r) -> reg u64 {
   reg u64 r;
   if (r == 0) { r = 0; }
   return r;
}
*/
