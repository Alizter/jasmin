export fn foo (#public reg u64 i) -> reg u64 {
  #transient stack u64[1] p;
  #transient stack u64 si;
  #msf reg u64 ms;
  #transient reg u64 r;
  #public reg bool b;
  #transient reg u64 it;

  /* init miss-speculation flag / mask to 0 (ie no miss-speculation)
     This correspond to the sequence 
     LFENCE;
     ms = 0;  
  */
  ms = #init_msf();

  p[0] = 1;
  si = i; // spill i into si
  b = i == 0;
  if (b) {
     ms = #set_msf(b, ms);
     it = si;
     i = #protect(it, ms);
     r = p[(int)i];
  } else {
     ms = #set_msf(!b, ms);
     r = p[0];
  }
  ? #LFENCE;
  return r;
}

inline fn test1(#poly=l1 stack u64[1] x) -> #poly={transient, l1} reg u64 {
   #poly={transient, l1} reg u64 r;
   r = x[0];
   return r;
}

export fn test1_app_secret(#secret reg u64 x) {
   #secrect stack u64[1] s;
   s[0] = x;
   x = test1(s);
}

export fn test1_app_public(#public reg u64 x) {
   #transient stack u64[1] s;
   #transient reg u64 r;
   #msf reg u64 ms;
   s[0] = x;
   r = test1(s);
   ms = #init_msf();
   x = #protect(r, ms);
}

/* This should fail 
export fn test1_app_fail(#public reg u64 x) {
   #transient stack u64[1] s;
   s[0] = x;
   x = test1(s);
}
*/



fn aux(#msf reg u64 ms, #public reg u64 p, #public reg u64 i) -> #msf reg u64, #public reg u64 {
 
   #public reg bool b;
  
   while 
    {b = i < 0;} 
    (b) 
    { [p] = 0; p += 1; ms = #set_msf(b, ms); i -= 1; }
   ms = #set_msf(!b, ms);
   return (ms, p);
   
}

/* This loop, need to fix the case of while */
/*
fn aux1(#msf reg u64 ms, #public reg u64 p, #public reg u64 i) -> #msf reg u64, #public reg u64 {
 
   #public reg bool b;
  
   while 
    {b = i < 0;} 
    (b) 
    { [p] = 0; p += 1; i -= 1; }
   ms = #init_msf();
   return (ms, p);
   
}
*/

fn aux1(#msf reg u64 ms, #transient reg ptr u64[1000]p) -> #msf reg u64, #public reg u64 {
 
   #public reg bool b;
   #transient reg u64 sum;
   #public reg u64 psum, i;
   sum = 0;
   i = 0; 
   while 
    {b = i < 1000;} 
    (b) 
    { sum += p[(int)i] ; ms=#set_msf(b, ms); i += 1; }
   ms = #set_msf(!b, ms);
   psum = #protect(sum, ms);

   return (ms, psum);
   
}

