// ** subtraction
// ************************************************************************

fn sub(reg u64[1] x) -> reg u64[1] {

  inline int i;

  for i = 0 to 1 {
    x[i] += 0;
  }

  return x;
}

// ** multiplication
// ************************************************************************

fn mul(stack u64[1] xa) -> reg u64[1] {

  reg u64[1] r;
  inline int i;

for i = 0 to 1 {
r[i] = xa[i];
}

  return r;
}

// ** ladderstep
// ************************************************************************

fn ladderstep(stack u64[1] x3p)
    -> (stack u64[1]) {

  reg u64[1] t3;
  reg u64[1] t8;

  t8      = mul(x3p);
  x3p      = t8;

  _      = sub(t8);
 
  return x3p;
}

// ** montgomery ladder
// ************************************************************************

fn mladder(stack u64[1] xr) {

    while (true) {
      xr = ladderstep(xr);
    }
}

// ** scalar multiplication
// ************************************************************************

 export fn scalarmult() {
  stack u64[1] xa;

  xa[0] = 0;
  mladder(xa);
 
}
