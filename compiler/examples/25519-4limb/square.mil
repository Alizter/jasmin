/* The implementation is parameterized by "n = number of limbs".
   For now, this code is specialized to n = 3 in some places.
   I did not completely specialize it since it might be easier
   to generalize the current version. */
fn square<n : u64>(xp : u64[n]) -> u64<n> {

  /*
  reg z : u64<2*n>;
  reg t : u64<3>;
  reg rax, rdx, c38, h, l, hprev, zero : u64;
  reg cf : bool;
  */

  if (i = 0) { }
  foo (i);

  z<7> = 0;

  /* sum up products x_i*x_j where j = i + 1 */
  for i in 0..(n - 1) {
    rax = xp[i + 1];
    rdx, rax = rax * xp[i];
    z<2*i + 1> = rax;
    z<2*i + 2> = rdx;
  }

  /* sum up products x_i*x_j where j = i + 2 */
  for i in 0..(n - 2) {
    rax = xp[i + 2];
    rdx, rax = rax * xp[i];
    cf, z<2*i + 2> += rax;
    cf, z<2*i + 3> += rdx + cf;
        z<2*i + 4> += 0   + cf;        
  }

  /* sum up products x_i*x_j where j = i + 3 */
  for i in 0..(n - 3) {
    rax = xp[i + 3];
    rdx, rax = rax * xp[i];
    cf, z<2*i + 3> += rax;
    cf, z<2*i + 4> += rdx + cf;
    cf, z<2*i + 5> += 0   + cf;
        z<2*i + 6> += 0   + cf;        
  }

  /* set z<1..2n+1> = 2*z<1..2n+1> since
     we have summed all x_i*x_j with i<>j
     so far and these occur twice */
  for i in 1..(2*n) {
    if (i = 1) {
      cf, z<i> += z<i>;
    } else {
      cf, z<i> += z<i> + cf;
    }
  }

  /* compute x_i*x_i for i=0..2 and store in
     z<0>|t<1>|t<2>|t<3>|rax|rdx  */
  for i in 0..2 {
    rax = xp[i];
    rdx, rax = rax * xp[i];
    if (i != 2) {
      if (i = 0) {
        z<0> = rax;
      } else {
        t<2*i> = rax;
      }
      t<2*i + 1> = rdx;
    }
  }

  for i in 0..3 {
    if (i = 0) {
      /* z<0> already set */
      cf, z<1> += t<1>;
    } else if (i < 2) {
      cf, z<2*i>     += t<2*i>     + cf;
      cf, z<2*i + 1> += t<2*i + 1> + cf;
    } else if (i = 2) {
      cf, z<2*i>     += rax + cf;
      cf, z<2*i + 1> += rdx + cf;
    } else { /* i > 2 */
      cf, z<2*i>     += 0 + cf;
      cf, z<2*i + 1> += 0 + cf;
    }
  }

  rax = xp[3];
  rdx, rax = rax * xp[3];
  cf, z<6> += rax;
      z<7> += rdx + cf;
  
  /* reduction from 8 limbs to 4 limbs (identical to mul.mil) */
  c38 = 38;
  for i in 0..n {
    rax = z<n+i>;
    h, l = rax * c38;
    cf, z<i> += l;
    if i = 0 {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf, z<i> += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * 38;
  cf, z<0> += l;

  for i in 1..n {
    cf, z<i> += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * 38;
  z<0> += l;
  
  return z<0..n>;
}

extern fn square_inplace<n : u64>(zp, xp : u64[n]) {
  reg z : u64<n>;
  z<0..n>  = square(xp);
  zp[0..n] = z<0..n>;
}

/*
Command exited with code 2.
Makefile:33: recipe for target 'dmasm' failed
make: *** [dmasm] Error 10
*/
