extern fn mul(zp, xp, yp0 /* rdx */) {

  yp = yp0;
  
  x[0] = *(xp);
  for j in 0..n {
    y[j] = *yp[j];
    h, l = y[j] * x[0];

    if j = 0 {
      z[0] = l;
      z[1] = h;
    } else {
      cf? z[j] += l;
      z[j + 1] = 0;
      z[j + 1] += h + cf;
    }
  }

  for i in 1..n {
    x[i] = *xp[i];
    for j in 0..n {
      y[j] = *yp[j];
      h, l = y[j] * x[i];
      cf? z[i+j] += l;
      if j = 0 {
        hprev = 0;
        hprev += h + cf;
      } else {
        h += 0 + cf;
        cf? z[i+j] += hprev;
        if 1 <= j && j < n {
          hprev = 0;
          hprev += h + cf;
        } else { /* j = n */
          z[i + j + 1] = 0;
          cf? z[i + j + 1] += h + cf;
        }
      }
    }
  }

  /* reduction from 8 limbs to 4 limbs */
  c38 = 38;
  for i in 0..n {
    rax = z[n + i + 1];
    h, l = rax * c38;
    cf? z[i] += l;
    if i = 0 {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf? z[i] += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * 38;
  cf? z[0] += l;

  for i in 1..n {
    cf? z[i] += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * 38;
  z[0] += l;

  for i in 0..n {
    *zp[i] = z[i];
  }
}
