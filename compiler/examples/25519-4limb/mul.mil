extern fn mul<n : u64>(zp, xp, yp0 : u64[n] /* rdx */) {

  reg yp   : u64[n];
  reg z    : u64<2*n>;
  reg x, y : u64<n>;
  reg h, l, hprev, c38, rax, zero : u64;
  reg cf : bool;

  yp = yp0;
  
  x<0> = xp[0];
  for j in 0..n {
    y<j> = yp[j];
    h, l = y<j> * x<0>;

    if j = 0 {
      z<0> = l;
      z<1> = h;
    } else {
      cf? z<j> += l;
      z<j+1> = 0;
      z<j+1> += h + cf;
    }
  }

  for i in 1..n {
    x<i> = xp[i];
    for j in 0..n {
      y<j> = yp[j];
      h, l = y<j> * x<i>;
      cf? z<i+j> += l;
      if j = 0 {
        hprev = 0;
        hprev += h + cf;
      } else {
        h += 0 + cf;
        cf? z<i+j> += hprev;
        if 1 <= j && j < n - 1 {
          hprev = 0;
          hprev += h + cf;
        } else { /* j = n - 1 */
          z<i+j+1> = 0;
          cf? z<i+j+1> += h + cf;
        }
      }
    }
  }

  /* reduction from 8 limbs to 4 limbs */
  c38 = 38;
  for i in 0..n {
    rax = z<n + i>;
    h, l = rax * c38;
    cf? z<i> += l;
    if i = 0 {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf? z<i> += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * 38;
  cf? z<0> += l;

  for i in 1..n {
    cf? z<i> += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * 38;
  z<0> += l;

  for i in 0..n {
    zp[i] = z<i>;
  }
}
