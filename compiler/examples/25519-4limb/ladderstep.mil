// * Implementation of montgomery ladder for curve25519

param n     : u64; /* the number of limbs */
param rem_p : u64; /* 2^(n*64) mod p      */

// ** addition
// ************************************************************************

fn add(reg x : u64[n], stack yp : u64[n]) -> reg u64[n] {

  reg  y : u64[n];
  reg  add0, add1 : u64;
  flag cf : bool;

  for i in 0..n {
    y[i] = yp[i];
    if (i = 0) { cf, x[0] += y[0]; }
    else       { cf, x[i] += y[i] + cf; }
  }

  add0 = 0;
  add1 = $rem_p;
  add1 = add0 if !cf;

  for i in  0..n {
    if (i = 0) {
      cf, x[0] += add1;
    } else {
      cf, x[i] += add0 + cf;
    }
  }

  add0 = add1 if cf;
  x[0] += add0;

  return x;
}

// ** subtraction
// ************************************************************************

fn sub(reg x : u64[n], stack yp : u64[n]) -> reg u64[n] {

  reg  y : u64[n];
  reg  sub0, sub1 : u64;
  flag cf : bool;

  for i in  0..n {
    y[i] = yp[i];
    if i = 0 {
      cf, x[0] -= y[0];
    } else {
      cf, x[i] -= y[i] - cf;
    }
  }

  sub0  = 0;
  sub1 = $rem_p;
  sub1 = sub0 if !cf;

  for i in  0..n {
    if i = 0 {
      cf, x[0] -= sub1;
    } else {
      cf, x[i] -= sub0 - cf;
    }
  }

  sub0 = sub1 if cf;
  x[0] -= sub0;

  return x;
}

// ** reduction from 8 limbs to 4 limbs
// ************************************************************************

fn reduce(reg z : u64[n*2]) -> reg u64[n*2] {
  reg crem_p, rax, l, h, hprev, zero : u64;
  reg cf : bool;

  crem_p = $rem_p;
  for i in 0..n {
    rax = z[n + i];
    h, l = rax * crem_p;
    cf, z[i] += l;
    if i = 0 {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf, z[i] += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * $rem_p;
  cf, z[0] += l;

  for i in 1..n {
    cf, z[i] += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * $rem_p;
  z[0] += l;

  return z;
}

// ** multiplication
// ************************************************************************

fn mul(stack xp, yp : u64[n]) -> reg u64[n] {

  reg z    : u64[n*2];
  reg r    : u64[n];
  reg x, y : u64[n];
  reg h, l, hprev, crem_p, rax, zero : u64;
  reg cf : bool;


  x[0] = xp[0];
  for j in 0..n {
    y[j] = yp[j];
    h, l = y[j] * x[0];

    if j = 0 {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      z[j + 1] = 0;
      z[j + 1] += h + cf;
    }
  }

  for i in 1..n {
    x[i] = xp[i];
    for j in 0..n {
      y[j] = yp[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if j = 0 {
        hprev = 0;
        hprev += h + cf;
      } else {
        h += 0 + cf;
        cf, z[i+j] += hprev;
        if 1 <= j && j < n - 1 {
          hprev = 0;
          hprev += h + cf;
        } else { /* j = n */
          z[i + j + 1] = 0;
          cf, z[i + j + 1] += h + cf;
        }
      }
    }
  }

  z = reduce(z);

  for i in 0..n { r[i] = z[i]; }
  return r;
}

// ** squaring
// ************************************************************************

fn square(stack xp : u64[n]) -> reg u64[n] {

  reg z : u64[n*2];
  reg r : u64[n];
  reg t : u64[3];
  reg rax, rdx, crem_p, h, l, hprev, zero : u64;
  reg cf : bool;

  z[7] = 0;

  /*   2*x01 + 2*x02 + 2*x03 + 2*x12 + 2*x13 + 2*x23
     + x00 + x11 + x22 + x33 */
  
  rax = xp[1];
  rdx, rax = rax * xp[0];
  z[1] = rax;
  z[2] = rdx;

  rax = xp[2];
  rdx, rax = rax * xp[1];
  z[3] = rax;
  z[4] = rdx;

  rax = xp[3];
  rdx, rax = rax * xp[2];
  z[5] = rax;
  z[6] = rdx;

  /*   [2*]x01 + 2*x02 + 2*x03 + [2*]x12 + 2*x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xp[2];
  rdx, rax = rax * xp[0];
  cf, z[2] += rax;
  cf, z[3] += rdx + cf;
      z[4] += 0   + cf;

  rax = xp[3];
  rdx, rax = rax * xp[1];
  cf, z[4] += rax;
  cf, z[5] += rdx + cf;
      z[6] += 0   + cf;

  /*   [2*]x01 + [2*]x02 + 2*x03 + [2*]x12 + [2*]x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xp[3];
  rdx, rax = rax * xp[0];
  cf, z[3] += rax;
  cf, z[4] += rdx + cf;
  cf, z[5] += 0   + cf;
      z[6] += 0   + cf;

  /*   x01 + x02 + x03 + x12 + x13 + x23
     + x00 + x11 + x22 + x33 */

  /* set z<1..2n+1> = 2*z<1..2n+1> since
     we have summed all x_i*x_j with i<>j
     so far and these occur twice */
  cf, z[1] += z[1];
  cf, z[2] += z[2] + cf;
  cf, z[3] += z[3] + cf;
  cf, z[4] += z[4] + cf;
  cf, z[5] += z[5] + cf;
  cf, z[6] += z[6] + cf;
  cf, z[7] += z[7] + cf;

  /* x00 + x11 + x22 + x33 */

  rax = xp[0];
  rdx, rax = rax * xp[0];
  z[0] = rax;
  t[1] = rdx;

  rax = xp[1];
  rdx, rax = rax * xp[1];
  t[2] = rax;
  t[3] = rdx;

  rax = xp[2];
  rdx, rax = rax * xp[2];
  t[4] = rax;
  t[5] = rdx;

  rax = xp[3];
  rdx, rax = rax * xp[3];

  cf, z[1] += t[1];
  cf, z[2] += t[2] + cf;
  cf, z[3] += t[3] + cf;
  cf, z[4] += t[4] + cf;
  cf, z[5] += t[5] + cf;
  cf, z[6] += 0 + cf;
      z[7] += 0 + cf;

  rax = xp[3];
  rdx, rax = rax * xp[3];
  cf, z[6] += rax;
      z[7] += rdx + cf;

  z = reduce(z);
  
  for i in 0..n { r[i] = z[i]; } // this should be a no-op and compile into equality constraint
  
  return r;
}

// ** ladderstep
// ************************************************************************

fn ladderstep(stack x1p, x2p, z2p, x3p, z3p : u64[n])
    -> stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] {
  reg t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8  : u64[n];
  stack t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p : u64[n];
  reg w1, w2, w3, w4, w5, w6, w7 : u64[n];
  stack c121666p : u64[n];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;
  
  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1      = x2p;
  t2      = t1;        
  t1      = add(t1,z2p);
  t2      = sub(t2,z2p);
  t1p     = t1;
  t2p     = t2;
  t7      = square(t2p);
  t7p     = t7;
  t6      = square(t1p);
  t6p     = t6;
  t5      = t6;
  t5      = sub(t5,t7p);
  t5p     = t5;
  t3      = x3p;
  t4      = t3;
  t3      = add(t3,z3p);
  t4      = sub(t4,z3p);
  t3p     = t3;
  t4p     = t4;
  t9      = mul(t3p,t2p);
  t9p     = t9;
  t8      = mul(t4p,t1p);
  w1      = t8;
  w1      = add(w1,t9p);

  t8      = sub(t8,t9p);
  x3p     = w1;
  z3p     = t8;
  w2      = square(x3p);
  x3p     = w2;
  w3      = square(z3p);
  z3p     = w3;
  w4      = mul(z3p,x1p);
  z3p     = w4;
  w5      = mul(t6p,t7p);
  x2p     = w5;
  w6      = mul(t5p,c121666p);
  w6      = add(w6,t7p);
  z2p     = w6;
  w7      = mul(z2p,t5p);
  z2p     = w7;

  return x2p, z2p, x3p, z3p;
}

// ** ladderstep (tracing version for debugging)
// ************************************************************************


fn ladderstep_tracing(
    stack x1p, x2p, z2p, x3p, z3p : u64[n]
  ) -> stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] *
       stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] *
       stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] *
       stack u64[n] * stack u64[n] * stack u64[n]
 {
  reg t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8  : u64[n];
  stack t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p : u64[n];
  reg w1, w2, w3, w4, w5, w6, w7 : u64[n];
  reg c121666p : u64[n];
  stack l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64[n];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;
  
  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1  = x2p;
  t2  = t1;            
  t1  = add(t1,z2p);       l1 = t1;    
  t2  = sub(t2,z2p);       l2 = t2;    
  t1p = t1;    
  t2p = t2;    
  t7  = square(t2p);       l3 = t7;    
  t7p = t7;    
  t6  = square(t1p);       l4 = t6;    
  t6p = t6;    
  t5  = t6;    
  t5  = sub(t5,t7p);       l5 = t5;    
  t5p = t5;    
  t3  = x3p;    
  t4  = t3;    
  t3  = add(t3,z3p);       l6 = t3;
  t4  = sub(t4,z3p);       l7 = t4;
  t3p = t3;    
  t4p = t4;    
  t9  = mul(t3p,t2p);      l8 = t9;
  t9p = t9;    
  t8  = mul(t4p,t1p);      l9 = t8;
  w1  = t8;    
  w1  = add(w1,t9p);       l10 = w1;

  t8  = sub(t8,t9p);       l11 = t8;
  x3p = w1;    
  z3p = t8;    
  w2  = square(x3p);       l12 = w2;
  x3p = w2;    
  w3  = square(z3p);       l13 = w3;
  z3p = w3;    
  w4  = mul(z3p,x1p);      l14 = w4;
  z3p = w4;    
  w5  = mul(t6p,t7p);      l15 = w5;
  x2p = w5;    
  w6  = mul(t5p,c121666p); l16 = w6;
  w6  = add(w6,t7p);       l17 = w6;
  z2p = w6;    
  w7  = mul(z2p,t5p);      l18 = w7;
  z2p = w7; 

  return l1,  l2, l3,   l4,  l5,
         l6,  l7, l8,   l9,  l10,
         l11, l12, l13, l14, l15,
         l16, l17, l18;
}

// ** cswap (FIXME: compare with OpenSSL, this is a translation from C)
// ************************************************************************

fn cswap(stack x2p, z2p, x3p, z3p : u64[n], stack swap : u64)
    -> stack u64[n] * stack u64[n] * stack u64[n] * stack u64[n] {
  reg tmp, mask : u64;
  mask = swap * 0xffffffffffffffff;

  for i in 0..n {
    tmp = x2p[i] ^ x3p[i];
    tmp = tmp & mask;
    x2p[i] = x2p[i] ^ tmp;
    x3p[i] = x3p[i] ^ tmp;

    tmp = z2p[i] ^ z3p[i];
    tmp = tmp & mask;
    z2p[i] = z2p[i] ^ tmp;
    z3p[i] = z3p[i] ^ tmp;
  }
  return x2p, z2p, x3p, z3p;
}


// ** montgomery ladder
// ************************************************************************

fn mladder(stack xr, zr, sp : u64[n]) -> stack u64[n] * stack u64[n] {
  stack s : u64;
  stack prevbit, bit, swap : u64;
  stack x1,x2,z2,x3,z3 : u64[n];
  
  //print_arr(xr); print_newline();
  //print_arr(zr); print_newline();
  //print_arr(sp); print_newline();
  //print_newline();

  prevbit = 0;

  x1 = xr;
  x2[0] = 1; x2[1] = 0; x2[2] = 0; x2[3] = 0;
  z2[0] = 0; z2[1] = 0; z2[2] = 0; z2[3] = 0;
  x3 = xr;
  z3[0] = 1; z3[1] = 0; z3[2] = 0; z3[3] = 0;
  
  for i in 0..4 {
    //print_u64($(3 -i)); print_u64(sp[3 - i]);
    //print_newline();
    //print_newline();
    s = sp[3 - i];
    for j in 0..64 {
      //print_u64($(64*(3 - i) + 63 - j));
      bit = s >> $(63 - j);
      bit = bit & 1;
      swap = bit ^ prevbit;
      //print_u64(bit);
      //print_u64(swap);
      //print_newline();
      prevbit = bit;
      x2,z2,x3,z3 = cswap(x2,z2,x3,z3,swap);
      x2,z2,x3,z3 = ladderstep(x1,x2,z2,x3,z3);
    }
    //print_newline();
    //print_newline();
  }
  x2,z2,x3,z3 = cswap(x2,z2,x3,z3,prevbit);
  return x2, z2;
}

// ** scalar multiplication
// ************************************************************************
/*
extern fn scalarmult(rp /* result */, sp /* secret scalar */, pp /* point */ : u64) {
}
*/

// ** tests
// ************************************************************************

fn rand_arr(stack s : u64) -> stack u64[n] = python rand;
fn assert_equal(stack x,y : u64[n]) = python assert_equal;
fn print_arr(stack x : u64[n]) = python print_u64_arr;
fn print_u64(stack x : u64) = python print_u64;
fn print_newline() = python print_newline;
fn assert_equal_add(stack x,y,z : u64[n]) = python assert_equal_add;
fn assert_equal_sub(stack x,y,z : u64[n]) = python assert_equal_sub;
fn assert_equal_mul(stack x,y,z : u64[n]) = python assert_equal_mul;
fn assert_equal_arr(stack x,y : u64[n]) = python assert_equal_arr;
fn assert_equal_ladderstep(stack x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r : u64[n])
  = python assert_equal_ladderstep;
fn assert_equal_ladderstep_tracing(stack x1,x2,z2,x3,z3
     ,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64[n])
  = python assert_equal_ladderstep_tracing;
fn assert_equal_mladder(stack xr, zr, sp, xr_r, zr_r : u64[n]) = python assert_equal_mladder;

fn test_add() {
  reg x, y_tmp, z : u64[n];
  stack y : u64[n];
  reg u : u64;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    y = y_tmp;
    z = add(x,y);
    assert_equal_add(x,y,z);
  }
}

fn test_sub() {
  reg x, y_tmp, z : u64[n];
  stack y : u64[n];
  reg u : u64;

  for i in 0..999 {
    u = $i;
    print_u64(u);
    x = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    y = y_tmp;
    z = sub(x,y);
    assert_equal_sub(x,y,z);
  }
}

fn test_mul() {
  reg   x_tmp, y_tmp, z : u64[n];
  stack x, y : u64[n];
  reg   u : u64;

  for i in 0..999 {
    u = $i;
    print_u64(u);
    x_tmp = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    x = x_tmp;
    y = y_tmp;
    z = mul(x,y);
    assert_equal_mul(x,y,z);
  }
}

fn test_square() {
  reg   x_tmp, y_tmp, z : u64[n];
  stack x : u64[n];
  reg   u : u64;

  for i in 0..999 {
    u = $i;
    print_u64(u);
    x_tmp = rand_arr(u);
    x = x_tmp;
    z = square(x);
    assert_equal_mul(x,x,z);
  }
}

fn test_ladderstep() {
  reg u : u64;
  reg x1, x2, z2, x3, z3 : u64[n];
  reg x2_r, z2_r, x3_r, z3_r : u64[n];

  for i in 0..1 {
    u = $i;
    print_u64(u);
    x1 = rand_arr(u); u += 1;
    x2 = rand_arr(u); u += 1;
    z2 = rand_arr(u); u += 1;
    x3 = rand_arr(u); u += 1;
    z3 = rand_arr(u); u += 1;

    x2_r, z2_r, x3_r, z3_r = ladderstep(x1, x2, z2, x3, z3);
    assert_equal_ladderstep(x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r);
  }
}

fn test_ladderstep_tracing() {
  reg u : u64;
  reg x1, x2, z2, x3, z3 : u64[n];
  reg x2_r, z2_r, x3_r, z3_r : u64[n];
  reg l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64[n];

  for i in 0..999 {
    u = $i;
    print_u64(u);
    x1 = rand_arr(u); u += 1;
    x2 = rand_arr(u); u += 1;
    z2 = rand_arr(u); u += 1;
    x3 = rand_arr(u); u += 1;
    z3 = rand_arr(u); u += 1;

    l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18
      = ladderstep_tracing(x1,x2,z2,x3,z3);
    assert_equal_ladderstep_tracing(x1, x2, z2, x3, z3,
      l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18);
  }
}

fn test_swap() {
  stack x2r, z2r, x3r, z3r : u64[n];
  stack x2r_a, z2r_a, x3r_a, z3r_a : u64[n];
  stack x2r_b, z2r_b, x3r_b, z3r_b : u64[n];
  stack u : u64;
  stack zero : u64;
  stack one  : u64;

  zero = 0;
  one = 1;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x2r = rand_arr(u); u += 1;
    z2r = rand_arr(u); u += 1;
    x3r = rand_arr(u); u += 1;
    z3r = rand_arr(u); u += 1;
    x2r_a, z2r_a, x3r_a, z3r_a = cswap(x2r,z2r,x3r,z3r,zero);
    x2r_b, z2r_b, x3r_b, z3r_b = cswap(x2r,z2r,x3r,z3r,one);

    assert_equal_arr(x2r, x2r_a);
    assert_equal_arr(z2r, z2r_a);
    assert_equal_arr(x3r, x3r_a);
    assert_equal_arr(z3r, z3r_a);

    assert_equal_arr(x2r, x3r_b);
    assert_equal_arr(z2r, z3r_b);
    assert_equal_arr(x3r, x2r_b);
    assert_equal_arr(z3r, z2r_b);
  }
}

fn test_mladder() {
  stack xr, zr : u64[n];
  stack xr_r, zr_r : u64[n];
  stack sp     : u64[n];
  stack u : u64;
  sp[0] = 0xffffffffffffffff;
  sp[1] = 0;
  sp[2] = 0x5555555555555555;
  sp[3] = 0xfffffffffffffffe;
  //print_arr(sp); print_newline();
  for i in 0..999 {
    u = $i;
    print_u64(u);
    xr = rand_arr(u); u += 1;
    zr = rand_arr(u); u += 1;
    xr_r, zr_r = mladder(xr,zr,sp);
    assert_equal_mladder(xr,zr,sp,xr_r,zr_r);
  }
}

fn test() {
  test_add();
  print_newline();
  test_sub();
  print_newline();
  test_mul();
  print_newline();
  test_square();
  print_newline();
  test_ladderstep_tracing();
  print_newline();
  test_ladderstep();
  print_newline();
  test_swap();
  print_newline();
  test_mladder();
}
