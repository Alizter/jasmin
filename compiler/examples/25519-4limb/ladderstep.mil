param int rem_p = 38; /* 2^(4*64) mod p      */

// ** addition
// ************************************************************************

fn add(reg u64[4] x, stack u64[4] ya) -> reg u64[4] {

  reg u64    add0;
  reg u64    add1;
  reg bool   cf;
  inline int i;

  for i = 0 to 4 {
    if   (i == 0) { cf, x[0] += ya[0]; }
    else          { cf, x[i] += ya[i] + cf; }
  }

  add0 = 0;
  add1 = rem_p;
  add1 = add0 if !cf;

  for i = 0 to 4 {
    if (i == 0) {
      cf, x[0] += add1;
    } else {
      cf, x[i] += add0 + cf;
    }
  }

  add0 = add1 if cf;
  x[0] += add0;

  return x;
}


// ** subtraction
// ************************************************************************

fn sub(reg u64[4] x, stack u64[4] ya) -> reg u64[4] {

  reg u64 sub0;
  reg u64 sub1;
  reg bool cf;
  inline int i;

  for i = 0 to 4 {
    if (i == 0) {
      cf, x[0] -= ya[0];
    } else {
      cf, x[i] -= ya[i] - cf;
    }
  }

  sub0  = 0;
  sub1 = rem_p;
  sub1 = sub0 if !cf;

  for i = 0 to 4 {
    if (i == 0) {
      cf, x[0] -= sub1;
    } else {
      cf, x[i] -= sub0 - cf;
    }
  }

  sub0 = sub1 if cf;
  x[0] -= sub0;

  return x;
}

// ** reduction from 8 limbs to 4 limbs
// ************************************************************************

fn reduce(reg u64[8] z) -> reg u64[4] {
  reg u64 crem_p;
  reg u64 rax;
  reg u64 l;
  reg u64 h;
  reg u64 hprev;
  reg u64 zero;
  reg u64[4] z_out;
  reg bool cf;
  inline int i;

  crem_p = rem_p;
  for i = 0 to 4 {
    rax = z[4 + i];
    h, l = rax * crem_p;
    cf, z_out[i] = z[i] + l;
    if (i == 0) {
      hprev = 0;
      _ , hprev += h + cf;
    } else {
      _, h += 0 + cf;
      cf, z_out[i] += hprev;
      hprev = 0;
      _, hprev += h + cf;
    }
  }

  l = hprev * rem_p;
  cf, z_out[0] += l;

  for i = 1 to 4 {
    cf, z_out[i] += 0 + cf;
  }

  zero = 0;
  _, zero += 0 + cf;

  l = zero * rem_p;
  z_out[0] += l;

  return z_out;
}

// ** multiplication
// ************************************************************************

fn mul(stack u64[4] xa, stack u64[4] ya) -> reg u64[4] {

  reg u64[8] z;
  reg u64[4] r;
  reg u64[4] x;
  reg u64[4] y;
  reg u64 h;
  reg u64 l;
  reg u64 hprev;
  reg bool cf;
  inline int i;
  inline int j;

  x[0] = xa[0];
  for j = 0 to 4 {
    y[j] = ya[j];
    h, l = y[j] * x[0];

    if (j == 0) {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      z[j + 1] = 0;
      _, z[j + 1] += h + cf;
    }
  }

  for i = 1 to 4 {
    x[i] = xa[i];
    for j = 0 to 4 {
      y[j] = ya[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if (j == 0) {
        hprev = 0;
        _, hprev += h + cf;
      } else {
        _, h += 0 + cf;
        cf, z[i+j] += hprev;
        if (1 <= j && j < 4 - 1) {
          hprev = 0;
          _, hprev += h + cf;
        } else { /* j = 4 */
          z[i + j + 1] = 0;
          cf, z[i + j + 1] += h + cf;
        }
      }
    }
  }

  r = reduce(z);

  return r;
}

// ** multiplication by small constant 121666
// ************************************************************************

fn mul121666(stack u64[4] xa) -> reg u64[4] {
 
  reg u64 rax;
  reg u64 rdx;
  reg u64 holdc;
  reg u64[4] z;
  reg u64 t1;
  reg u64 t2;
  reg u64 t3;
  reg u64 t4;
  reg bool cf;

  holdc = 121666;

  rax = xa[0];
  rdx, rax = rax * holdc;
  z[0] = rax;
  z[1] = rdx;

  rax = xa[2];
  rdx, rax = rax * holdc;
  z[2] = rax;
  z[3] = rdx;

  rax = xa[1];
  rdx, rax = rax * holdc;
  t1 = rax;
  t2 = rdx;

  rax = xa[3];
  rdx, rax = rax * holdc;
  t3 = rax;
  t4 = rdx;

  cf, z[1] += t1;
  cf, z[2] += t2 + cf;
  cf, z[3] += t3 + cf;
  _, t4 += 0 + cf;
  _, t4 *= 38;

  cf, z[0] += t4;
  cf, z[1] += 0 + cf;
  cf, z[2] += 0 + cf;
  cf, z[3] += 0 + cf;

  t1 = 38;
  t2 = 0;
  t1 = t2 if !cf;
  z[0] += t1;

  return z;
}

// ** squaring
// ************************************************************************

fn square(stack u64[4] xa) -> reg u64[4] {

  reg u64[8] z;
  reg u64[4] r;
  reg u64[5] t;
  reg u64 rax;
  reg u64 rdx;
  reg bool cf;

  z[7] = 0;

  /*   2*x01 + 2*x02 + 2*x03 + 2*x12 + 2*x13 + 2*x23
     + x00 + x11 + x22 + x33 */

  rax = xa[1];
  rdx, rax = rax * xa[0];
  z[1] = rax;
  z[2] = rdx;

  rax = xa[2];
  rdx, rax = rax * xa[1];
  z[3] = rax;
  z[4] = rdx;

  rax = xa[3];
  rdx, rax = rax * xa[2];
  z[5] = rax;
  z[6] = rdx;

  /*   [2*]x01 + 2*x02 + 2*x03 + [2*]x12 + 2*x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xa[2];
  rdx, rax = rax * xa[0];
  cf, z[2] += rax;
  cf, z[3] += rdx + cf;
      _, z[4] += 0   + cf;

  rax = xa[3];
  rdx, rax = rax * xa[1];
  cf, z[4] += rax;
  cf, z[5] += rdx + cf;
   _, z[6] += 0   + cf;

  /*   [2*]x01 + [2*]x02 + 2*x03 + [2*]x12 + [2*]x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xa[3];
  rdx, rax = rax * xa[0];
  cf, z[3] += rax;
  cf, z[4] += rdx + cf;
  cf, z[5] += 0   + cf;
  cf, z[6] += 0   + cf;
  _,  z[7] += 0   + cf;

  /*   x01 + x02 + x03 + x12 + x13 + x23
     + x00 + x11 + x22 + x33 */

  /* set z<1..2n+1> = 2*z<1..2n+1> since
     we have summed all x_i*x_j with i<>j
     so far and these occur twice */
  cf, z[1] += z[1];
  cf, z[2] += z[2] + cf;
  cf, z[3] += z[3] + cf;
  cf, z[4] += z[4] + cf;
  cf, z[5] += z[5] + cf;
  cf, z[6] += z[6] + cf;
  cf, z[7] += z[7] + cf;

  /* x00 + x11 + x22 + x33 */

  rax = xa[0];
  rdx, rax = rax * xa[0];
  z[0] = rax;
  t[0] = rdx;

  rax = xa[1];
  rdx, rax = rax * xa[1];
  t[1] = rax;
  t[2] = rdx;

  rax = xa[2];
  rdx, rax = rax * xa[2];
  t[3] = rax;
  t[4] = rdx;

  cf, z[1] += t[0];
  cf, z[2] += t[1] + cf;
  cf, z[3] += t[2] + cf;
  cf, z[4] += t[3] + cf;
  cf, z[5] += t[4] + cf;
  cf, z[6] += 0 + cf;
  _, z[7] += 0 + cf;

  rax = xa[3];
  rdx, rax = rax * xa[3];
  cf, z[6] += rax;
   _, z[7] += rdx + cf;

  r = reduce(z);

  return r;
}

// ** ladderstep
// ************************************************************************

fn ladderstep(stack u64[4] x1p, stack u64[4] x2p, stack u64[4] z2p, stack u64[4] x3p, stack u64[4] z3p)
    -> (stack u64[4] , stack u64[4] , stack u64[4] , stack u64[4]) {


  reg u64[4] t1;
  reg u64[4] t2;
  reg u64[4] t7;
  reg u64[4] t6;
  reg u64[4] t5;
  reg u64[4] t3;
  reg u64[4] t4;
  reg u64[4] t9;
  reg u64[4] t8;
  stack u64[4] t1p;
  stack u64[4] t2p;
  stack u64[4] t7p;
  stack u64[4] t6p;
  stack u64[4] t5p;
  stack u64[4] t3p;
  stack u64[4] t4p;
  stack u64[4] t9p;
  reg u64[4] w1;
  reg u64[4] w2;
  reg u64[4] w3;
  reg u64[4] w4;
  reg u64[4] w5;
  reg u64[4] w6;
  reg u64[4] w7;

  t1      = x2p;
  t2      = t1;
  t1      = add(t1,z2p);
  t2      = sub(t2,z2p);
  t1p     = t1;
  t2p     = t2;
  t7      = square(t2p);
  t7p     = t7;
  t6      = square(t1p);
  t6p     = t6;
  t5      = t6;
  t5      = sub(t5,t7p);
  t5p     = t5;
  t3      = x3p;
  t4      = t3;
  t3      = add(t3,z3p);
  t4      = sub(t4,z3p);
  t3p     = t3;
  t4p     = t4;
  t9      = mul(t3p,t2p);
  t9p     = t9;
  t8      = mul(t4p,t1p);
  w1      = t8;
  w1      = add(w1,t9p);

  t8      = sub(t8,t9p);
  x3p     = w1;
  z3p     = t8;
  w2      = square(x3p);
  x3p     = w2;
  w3      = square(z3p);
  z3p     = w3;
  w4      = mul(z3p,x1p);
  z3p     = w4;
  w5      = mul(t6p,t7p);
  x2p     = w5;
  w6      = mul121666(t5p);
  w6      = add(w6,t7p);
  z2p     = w6;
  w7      = mul(z2p,t5p);
  z2p     = w7;
 
  return x2p, z2p, x3p, z3p;
}

export fn crypto_scalarmult_curve25519_amd64_64_ladderstep( 
          reg u64 workp) {
   stack u64[4] x1p;
   stack u64[4] x2p;
   stack u64[4] z2p;
   stack u64[4] x3p;
   stack u64[4] z3p;
   stack u64[4] r1;
   stack u64[4] r2;
   stack u64[4] r3;
   stack u64[4] r4;
   stack u64[4] c121666p;

   reg u64 buf;
   inline int i;

   c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;

  for i = 0 to 4 { buf = [workp + 8*i]; x1p[i] = buf; }
   for i = 0 to 4 { buf = [workp + 32 + 8*i]; x2p[i] = buf; }
   for i = 0 to 4 { buf = [workp + 64 + 8*i]; z2p[i] = buf; }
   for i = 0 to 4 { buf = [workp + 96 + 8*i]; x3p[i] = buf; }
   for i = 0 to 4 { buf = [workp + 128 + 8*i]; z3p[i] = buf; }

   r1,r2,r3,r4 = ladderstep(x1p,x2p,z2p,x3p,z3p);

   for i = 0 to 4 { buf = r1[i]; [workp + 32 + 8*i] = buf; }
   for i = 0 to 4 { buf = r2[i]; [workp + 64 + 8*i] = buf; }
   for i = 0 to 4 { buf = r3[i]; [workp + 96 + 8*i] = buf; }
   for i = 0 to 4 { buf = r4[i]; [workp + 128 + 8*i] = buf; }
}
