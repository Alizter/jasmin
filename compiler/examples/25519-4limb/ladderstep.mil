// * Implementation of montgomery ladder for curve25519

param n     : u64; /* the number of limbs */
param rem_p : u64; /* 2^(n*64) mod p        */

// ** addition
// ************************************************************************

fn add(x : u64<n>, yp : u64[n]) -> u64<n> {

  reg y : u64<n>;
  reg add0, add1 : u64;
  flag cf : bool;

  for i in 0..n {
    y[i] = yp[i];
    if (i = 0) { cf, x[0] += y[0]; }
    else       { cf, x[i] += y[i] + cf; }
  }

  add0 = 0;
  add1 = $rem_p;
  add1 = add0 if !cf;

  for i in  0..n {
    if (i = 0) {
      cf, x[0] += add1;
    } else {
      cf, x[i] += add0 + cf;
    }
  }

  add0 = add1 if cf;
  x[0] += add0;

  return x[..];
}

// ** subtraction
// ************************************************************************

fn sub(x : u64<n>, yp : u64[n]) -> u64<n> {

  reg y : u64<n>;
  reg sub0, sub1 : u64;
  flag cf : bool;

  for i in  0..n {
    y[i] = yp[i];
    if i = 0 {
      cf, x[0] -= y[0];
    } else {
      cf, x[i] -= y[i] - cf;
    }
  }

  sub0  = 0;
  sub1 = $rem_p;
  sub1 = sub0 if !cf;

  for i in  0..n {
    if i = 0 {
      cf, x[0] -= sub1;
    } else {
      cf, x[i] -= sub0 - cf;
    }
  }

  sub0 = sub1 if cf;
  x[0] -= sub0;

  return x[..];
}

// ** reduction from 8 limbs to 4 limbs
// ************************************************************************

fn reduce(z : u64<n*2>) -> u64<n*2> {
  reg crem_p, rax, l, h, hprev, zero : u64;
  reg cf : bool;

  crem_p = $rem_p;
  for i in 0..n {
    rax = z[n + i];
    h, l = rax * crem_p;
    cf, z[i] += l;
    if i = 0 {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf, z[i] += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * $rem_p;
  cf, z[0] += l;

  for i in 1..n {
    cf, z[i] += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * $rem_p;
  z[0] += l;

  return z[..];
}

// ** multiplication
// ************************************************************************

fn mul(xp, yp0 : u64[n] /* rdx */) -> u64<n> {

  reg yp   : u64[n];
  reg z    : u64<n*2>;
  reg x, y : u64<n>;
  reg h, l, hprev, crem_p, rax, zero : u64;
  reg cf : bool;

  yp = yp0;

  x[0] = xp[0];
  for j in 0..n {
    y[j] = yp[j];
    h, l = y[j] * x[0];

    if j = 0 {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      z[j + 1] = 0;
      z[j + 1] += h + cf;
    }
  }

  for i in 1..n {
    x[i] = xp[i];
    for j in 0..n {
      y[j] = yp[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if j = 0 {
        hprev = 0;
        hprev += h + cf;
      } else {
        h += 0 + cf;
        cf, z[i+j] += hprev;
        if 1 <= j && j < n - 1 {
          hprev = 0;
          hprev += h + cf;
        } else { /* j = n */
          z[i + j + 1] = 0;
          cf, z[i + j + 1] += h + cf;
        }
      }
    }
  }

  z[..] = reduce(z[..]);

  x[..] = z[0..n];
  return x[..];
}

// ** squaring
// ************************************************************************

fn square(xp : u64[n]) -> u64<n> {

  reg z : u64<n*2>;
  reg t : u64<3>;
  reg rax, rdx, crem_p, h, l, hprev, zero : u64;
  reg cf : bool;

  z[7] = 0;

  /*   2*x01 + 2*x02 + 2*x03 + 2*x12 + 2*x13 + 2*x23
     + x00 + x11 + x22 + x33 */
  
  rax = xp[1];
  rdx, rax = rax * xp[0];
  z[1] = rax;
  z[2] = rdx;

  rax = xp[2];
  rdx, rax = rax * xp[1];
  z[3] = rax;
  z[4] = rdx;

  rax = xp[3];
  rdx, rax = rax * xp[2];
  z[5] = rax;
  z[6] = rdx;

  /*   [2*]x01 + 2*x02 + 2*x03 + [2*]x12 + 2*x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xp[2];
  rdx, rax = rax * xp[0];
  cf, z[2] += rax;
  cf, z[3] += rdx + cf;
      z[4] += 0   + cf;

  rax = xp[3];
  rdx, rax = rax * xp[1];
  cf, z[4] += rax;
  cf, z[5] += rdx + cf;
      z[6] += 0   + cf;

  /*   [2*]x01 + [2*]x02 + 2*x03 + [2*]x12 + [2*]x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xp[3];
  rdx, rax = rax * xp[0];
  cf, z[3] += rax;
  cf, z[4] += rdx + cf;
  cf, z[5] += 0   + cf;
      z[6] += 0   + cf;

  /*   x01 + x02 + x03 + x12 + x13 + x23
     + x00 + x11 + x22 + x33 */

  /* set z<1..2n+1> = 2*z<1..2n+1> since
     we have summed all x_i*x_j with i<>j
     so far and these occur twice */
  cf, z[1] += z[1];
  cf, z[2] += z[2] + cf;
  cf, z[3] += z[3] + cf;
  cf, z[4] += z[4] + cf;
  cf, z[5] += z[5] + cf;
  cf, z[6] += z[6] + cf;
  cf, z[7] += z[7] + cf;

  /* x00 + x11 + x22 + x33 */

  rax = xp[0];
  rdx, rax = rax * xp[0];
  z[0] = rax;
  t[1] = rdx;

  rax = xp[1];
  rdx, rax = rax * xp[1];
  t[2] = rax;
  t[3] = rdx;

  rax = xp[2];
  rdx, rax = rax * xp[2];
  t[4] = rax;
  t[5] = rdx;

  rax = xp[3];
  rdx, rax = rax * xp[3];

  cf, z[1] += t[1];
  cf, z[2] += t[2] + cf;
  cf, z[3] += t[3] + cf;
  cf, z[4] += t[4] + cf;
  cf, z[5] += t[5] + cf;
  cf, z[6] += 0 + cf;
      z[7] += 0 + cf;

  rax = xp[3];
  rdx, rax = rax * xp[3];
  cf, z[6] += rax;
      z[7] += rdx + cf;

  z[..] = reduce(z[..]);

  return z[0..n];
}

// ** ladderstep
// ************************************************************************

fn ladderstep(x1p, x2p, z2p, x3p, z3p : u64[n]) -> u64<n> * u64<n> * u64<n> * u64<n> {
  reg t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8  : u64<n>;
  reg t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p : u64[n];
  reg w1, w2, w3, w4, w5, w6, w7 : u64<n>;
  reg c121666p : u64[n];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;
  
  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1[..]  = x2p[..];
  t2[..]  = t1[..];        
  t1[..]  = add(t1,z2p);
  t2[..]  = sub(t2,z2p);
  t1p[..] = t1[..];
  t2p[..] = t2[..];
  t7[..]  = square(t2p);
  t7p[..] = t7[..];
  t6[..]  = square(t1p);
  t6p[..] = t6[..];
  t5[..]  = t6[..];
  t5[..]  = sub(t5,t7p);
  t5p[..] = t5[..];
  t3[..]  = x3p[..];
  t4[..]  = t3[..];
  t3[..]  = add(t3,z3p);
  t4[..]  = sub(t4,z3p);
  t3p[..] = t3[..];
  t4p[..] = t4[..];
  t9[..]  = mul(t3p,t2p);
  t9p[..] = t9[..];
  t8[..]  = mul(t4p,t1p);
  w1[..]  = t8[..];
  w1[..]  = add(w1,t9p);

  t8[..]  = sub(t8,t9p);
  x3p[..] = w1[..];
  z3p[..] = t8[..];
  w2[..]  = square(x3p);
  x3p[..] = w2[..];
  w3[..]  = square(z3p);
  z3p[..] = w3[..];
  w4[..]  = mul(z3p,x1p);
  z3p[..] = w4[..];
  w5[..]  = mul(t6p,t7p);
  x2p[..] = w5[..];
  w6[..]  = mul(t5p,c121666p);
  w6[..]  = add(w6,t7p);
  z2p[..] = w6[..];
  w7[..]  = mul(z2p,t5p);
  z2p[..] = w7[..];

  return x2p[..], z2p[..], x3p[..], z3p[..];
}

// ** ladderstep (tracing version for debugging)
// ************************************************************************

fn ladderstep_tracing(
    x1p, x2p, z2p, x3p, z3p : u64[n]
  ) -> u64<n> * u64<n> * u64<n> * u64<n> * u64<n> *
       u64<n> * u64<n> * u64<n> * u64<n> * u64<n> *
       u64<n> * u64<n> * u64<n> * u64<n> * u64<n> *
       u64<n> * u64<n> * u64<n>
 {
  reg t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8  : u64<n>;
  reg t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p : u64[n];
  reg w1, w2, w3, w4, w5, w6, w7 : u64<n>;
  reg c121666p : u64[n];
  reg l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64<n>;

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;
  
  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1[..]  = x2p[..];
  t2[..]  = t1[..];        
  t1[..]  = add(t1,z2p);       l1[..] = t1[..];
  t2[..]  = sub(t2,z2p);       l2[..] = t2[..];
  t1p[..] = t1[..];
  t2p[..] = t2[..];
  t7[..]  = square(t2p);       l3[..] = t7[..];
  t7p[..] = t7[..];
  t6[..]  = square(t1p);       l4[..] = t6[..];
  t6p[..] = t6[..];
  t5[..]  = t6[..];
  t5[..]  = sub(t5,t7p);       l5[..] = t5[..];
  t5p[..] = t5[..];
  t3[..]  = x3p[..];
  t4[..]  = t3[..];
  t3[..]  = add(t3,z3p);       l6[..] = t3[..];
  t4[..]  = sub(t4,z3p);       l7[..] = t4[..];
  t3p[..] = t3[..];
  t4p[..] = t4[..];
  t9[..]  = mul(t3p,t2p);      l8[..] = t9[..];
  t9p[..] = t9[..];
  t8[..]  = mul(t4p,t1p);      l9[..] = t8[..];
  w1[..]  = t8[..];
  w1[..]  = add(w1,t9p);       l10[..] = w1[..];

  t8[..]  = sub(t8,t9p);       l11[..] = t8[..];
  x3p[..] = w1[..];
  z3p[..] = t8[..];
  w2[..]  = square(x3p);       l12[..] = w2[..];
  x3p[..] = w2[..];
  w3[..]  = square(z3p);       l13[..] = w3[..];
  z3p[..] = w3[..];
  w4[..]  = mul(z3p,x1p);      l14[..] = w4[..];
  z3p[..] = w4[..];
  w5[..]  = mul(t6p,t7p);      l15[..] = w5[..];
  x2p[..] = w5[..];
  w6[..]  = mul(t5p,c121666p); l16[..] = w6[..];
  w6[..]  = add(w6,t7p);       l17[..] = w6[..];
  z2p[..] = w6[..];
  w7[..]  = mul(z2p,t5p);      l18[..] = w7[..];
  z2p[..] = w7[..];

  return l1[..],  l2[..], l3[..], l4[..], l5[..],
         l6[..],  l7[..], l8[..], l9[..], l10[..],
         l11[..], l12[..], l13[..], l14[..], l15[..],
         l16[..], l17[..], l18[..];
}

// ** tests
// ************************************************************************

fn rand_arr(s : u64) -> u64<n> = python rand;
fn assert_equal(x, y : u64<n>) = python assert_equal;
fn mul_py(x, y : u64[n]) -> u64<n> = python mul_py;
fn print_arr(x : u64<n>) = python print_u64_arr;
fn print_u64(x : u64) = python print_u64;
fn print_newline() = python print_newline;
fn assert_equal_add(x, y, z : u64<n>) = python assert_equal_add;
fn assert_equal_sub(x, y, z : u64<n>) = python assert_equal_sub;
fn assert_equal_mul(x, y : u64[n], z : u64<n>) = python assert_equal_mul;
fn assert_equal_ladderstep(x1, x2, z2, x3, z3, x2_r, z2_r, x3_r, z3_r : u64<n>)
  = python assert_equal_ladderstep;
fn assert_equal_test(c : u64<n>) = python assert_equal_test;
fn assert_equal_ladderstep_tracing(x1,x2,z2,x3,z3
     ,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64<n>)
  = python assert_equal_ladderstep_tracing;

fn test_add() {
  reg x, y_tmp, z : u64<n>;
  reg y : u64[n];
  reg u : u64;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x[..] = rand_arr(u);
    u += 1;
    y_tmp[..] = rand_arr(u);
    y[..] = y_tmp[..];
    z[..] = add(x[..],y[..]);
    assert_equal_add(x[..],y[..],z[..]);
 }
}

fn test_sub() {
  reg x, y_tmp, z : u64<n>;
  reg y : u64[n];
  reg u : u64;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x[..] = rand_arr(u);
    u += 1;
    y_tmp[..] = rand_arr(u);
    y[..] = y_tmp[..];
    z[..] = sub(x[..],y);
    assert_equal_sub(x[..],y[..],z[..]);
  }
}

fn test_mul() {
  reg x_tmp, y_tmp, z : u64<n>;
  reg x, y : u64[n];
  reg u : u64;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x_tmp[..] = rand_arr(u);
    u += 1;
    y_tmp[..] = rand_arr(u);
    x[..] = x_tmp[..];
    y[..] = y_tmp[..];
    z[..] = mul(x,y);
    assert_equal_mul(x,y,z[..]);
 }
}

fn test_square() {
  reg x_tmp, y_tmp, z : u64<n>;
  reg x : u64[n];
  reg u : u64;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x_tmp[..] = rand_arr(u);
    x[..] = x_tmp[..];
    z[..] = square(x);
    assert_equal_mul(x,x,z[..]);
  }
}

fn test_ladderstep() {
  reg u : u64;
  reg x1, x2, z2, x3, z3 : u64<n>;
  reg x2_r, z2_r, x3_r, z3_r : u64<n>;
  reg l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64<n>;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x1[..] = rand_arr(u); u += 1;
    x2[..] = rand_arr(u); u += 1;
    z2[..] = rand_arr(u); u += 1;
    x3[..] = rand_arr(u); u += 1;
    z3[..] = rand_arr(u); u += 1;

    x2_r[..], z2_r[..], x3_r[..], z3_r[..]
      = ladderstep(x1, x2, z2, x3, z3);
    assert_equal_ladderstep(x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r);
  }
}

fn test_ladderstep_tracing() {
  reg u : u64;
  reg x1, x2, z2, x3, z3 : u64<n>;
  reg x2_r, z2_r, x3_r, z3_r : u64<n>;
  reg l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64<n>;
  for i in 0..999 {
    u = $i;
    print_u64(u);
    x1[..] = rand_arr(u); u += 1;
    x2[..] = rand_arr(u); u += 1;
    z2[..] = rand_arr(u); u += 1;
    x3[..] = rand_arr(u); u += 1;
    z3[..] = rand_arr(u); u += 1;

    //x2_r[..], z2_r[..], x3_r[..], z3_r[..]
    //  = ladderstep(x1, x2, z2, x3, z3);
    // assert_equal_ladderstep(x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r);
    l1[..],  l2[..], l3[..], l4[..], l5[..],
      l6[..],  l7[..], l8[..], l9[..], l10[..],
      l11[..], l12[..], l13[..], l14[..], l15[..],
      l16[..], l17[..], l18[..]
      = ladderstep_tracing(x1, x2, z2, x3, z3);
    assert_equal_ladderstep_tracing(x1, x2, z2, x3, z3,
      l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18);
  }
}

fn test() {
  test_add();
  print_newline();
  test_sub();
  print_newline();
  test_mul();
  print_newline();
  test_square();
  print_newline();
  //test_ladderstep_tracing();
  test_ladderstep();
  print_newline();
}
