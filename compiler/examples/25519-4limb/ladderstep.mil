// * Implementation of montgomery ladder for curve25519

/* param n     : u64; the number of limbs is fixed for now */
param rem_p : u64; /* 2^(n*64) mod p      */

// ** addition
// ************************************************************************

fn add(reg x : u64[4], stack ya : u64[4]) -> reg u64[4] {

  reg  y : u64[4];
  reg  add0, add1 : u64;
  flag cf : bool;
  inline i : u64;

  for i in 0..4 {
    y[i] = ya[i];
    if (i = 0) { cf, x[0] += y[0]; }
    else       { cf, x[i] += y[i] + cf; }
  }

  add0 = 0;
  add1 = $rem_p;
  add1 = add0 if !cf;

  for i in  0..4 {
    if (i = 0) {
      cf, x[0] += add1;
    } else {
      cf, x[i] += add0 + cf;
    }
  }

  add0 = add1 if cf;
  x[0] += add0;

  return x;
}

// ** subtraction
// ************************************************************************

fn sub(reg x : u64[4], stack ya : u64[4]) -> reg u64[4] {

  reg  y : u64[4];
  reg  sub0, sub1 : u64;
  flag cf : bool;
  inline i : u64;

  for i in  0..4 {
    y[i] = ya[i];
    if i = 0 {
      cf, x[0] -= y[0];
    } else {
      cf, x[i] -= y[i] - cf;
    }
  }

  sub0  = 0;
  sub1 = $rem_p;
  sub1 = sub0 if !cf;

  for i in  0..4 {
    if i = 0 {
      cf, x[0] -= sub1;
    } else {
      cf, x[i] -= sub0 - cf;
    }
  }

  sub0 = sub1 if cf;
  x[0] -= sub0;

  return x;
}

// ** reduction from 8 limbs to 4 limbs
// ************************************************************************

fn reduce(reg z : u64[4*2]) -> reg u64[4*2] {
  reg crem_p, rax, l, h, hprev, zero : u64;
  reg cf : bool;
  inline i : u64;

  crem_p = $rem_p;
  for i in 0..4 {
    rax = z[4 + i];
    h, l = rax * crem_p;
    cf, z[i] += l;
    if i = 0 {
      hprev = 0;
      hprev += h + cf;
    } else {
      h += 0 + cf;
      cf, z[i] += hprev;
      hprev = 0;
      hprev += h + cf;
    }
  }

  l = hprev * $rem_p;
  cf, z[0] += l;

  for i in 1..4 {
    cf, z[i] += 0 + cf;
  }

  zero = 0;
  zero += 0 + cf;

  l = zero * $rem_p;
  z[0] += l;

  return z;
}

// ** multiplication
// ************************************************************************

fn mul(stack xa, ya : u64[4]) -> reg u64[4] {

  reg z    : u64[4*2];
  reg r    : u64[4];
  reg x, y : u64[4];
  reg h, l, hprev, crem_p, rax, zero : u64;
  reg cf : bool;
  inline i, j : u64;

  x[0] = xa[0];
  for j in 0..4 {
    y[j] = ya[j];
    h, l = y[j] * x[0];

    if j = 0 {
      z[0] = l;
      z[1] = h;
    } else {
      cf, z[j] += l;
      z[j + 1] = 0;
      z[j + 1] += h + cf;
    }
  }

  for i in 1..4 {
    x[i] = xa[i];
    for j in 0..4 {
      y[j] = ya[j];
      h, l = y[j] * x[i];
      cf, z[i+j] += l;
      if j = 0 {
        hprev = 0;
        hprev += h + cf;
      } else {
        h += 0 + cf;
        cf, z[i+j] += hprev;
        if 1 <= j && j < 4 - 1 {
          hprev = 0;
          hprev += h + cf;
        } else { /* j = 4 */
          z[i + j + 1] = 0;
          cf, z[i + j + 1] += h + cf;
        }
      }
    }
  }

  z = reduce(z);

  for i in 0..4 { r[i] = z[i]; }
  return r;
}

// ** squaring
// ************************************************************************

fn square(stack xa : u64[4]) -> reg u64[4] {

  reg z : u64[4*2];
  reg r : u64[4];
  reg t : u64[3];
  reg rax, rdx, crem_p, h, l, hprev, zero : u64;
  reg cf : bool;
  inline i : u64;

  z[7] = 0;

  /*   2*x01 + 2*x02 + 2*x03 + 2*x12 + 2*x13 + 2*x23
     + x00 + x11 + x22 + x33 */

  rax = xa[1];
  rdx, rax = rax * xa[0];
  z[1] = rax;
  z[2] = rdx;

  rax = xa[2];
  rdx, rax = rax * xa[1];
  z[3] = rax;
  z[4] = rdx;

  rax = xa[3];
  rdx, rax = rax * xa[2];
  z[5] = rax;
  z[6] = rdx;

  /*   [2*]x01 + 2*x02 + 2*x03 + [2*]x12 + 2*x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xa[2];
  rdx, rax = rax * xa[0];
  cf, z[2] += rax;
  cf, z[3] += rdx + cf;
      z[4] += 0   + cf;

  rax = xa[3];
  rdx, rax = rax * xa[1];
  cf, z[4] += rax;
  cf, z[5] += rdx + cf;
      z[6] += 0   + cf;

  /*   [2*]x01 + [2*]x02 + 2*x03 + [2*]x12 + [2*]x13 + [2*]x23
     + x00 + x11 + x22 + x33 */

  rax = xa[3];
  rdx, rax = rax * xa[0];
  cf, z[3] += rax;
  cf, z[4] += rdx + cf;
  cf, z[5] += 0   + cf;
      z[6] += 0   + cf;

  /*   x01 + x02 + x03 + x12 + x13 + x23
     + x00 + x11 + x22 + x33 */

  /* set z<1..2n+1> = 2*z<1..2n+1> since
     we have summed all x_i*x_j with i<>j
     so far and these occur twice */
  cf, z[1] += z[1];
  cf, z[2] += z[2] + cf;
  cf, z[3] += z[3] + cf;
  cf, z[4] += z[4] + cf;
  cf, z[5] += z[5] + cf;
  cf, z[6] += z[6] + cf;
  cf, z[7] += z[7] + cf;

  /* x00 + x11 + x22 + x33 */

  rax = xa[0];
  rdx, rax = rax * xa[0];
  z[0] = rax;
  t[1] = rdx;

  rax = xa[1];
  rdx, rax = rax * xa[1];
  t[2] = rax;
  t[3] = rdx;

  rax = xa[2];
  rdx, rax = rax * xa[2];
  t[4] = rax;
  t[5] = rdx;

  rax = xa[3];
  rdx, rax = rax * xa[3];

  cf, z[1] += t[1];
  cf, z[2] += t[2] + cf;
  cf, z[3] += t[3] + cf;
  cf, z[4] += t[4] + cf;
  cf, z[5] += t[5] + cf;
  cf, z[6] += 0 + cf;
      z[7] += 0 + cf;

  rax = xa[3];
  rdx, rax = rax * xa[3];
  cf, z[6] += rax;
      z[7] += rdx + cf;

  z = reduce(z);

  for i in 0..4 { r[i] := z[i]; } // this should be a no-op and compile into equality constraint

  return r;
}

// ** ladderstep
// ************************************************************************

fn ladderstep(stack x1p, x2p, z2p, x3p, z3p : u64[4])
    -> stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] {
  reg t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8  : u64[4];
  stack t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p : u64[4];
  reg w1, w2, w3, w4, w5, w6, w7 : u64[4];
  stack c121666p : u64[4];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;

  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1      = x2p;
  t2      = t1;
  t1      = add(t1,z2p);
  t2      = sub(t2,z2p);
  t1p     = t1;
  t2p     = t2;
  t7      = square(t2p);
  t7p     = t7;
  t6      = square(t1p);
  t6p     = t6;
  t5      = t6;
  t5      = sub(t5,t7p);
  t5p     = t5;
  t3      = x3p;
  t4      = t3;
  t3      = add(t3,z3p);
  t4      = sub(t4,z3p);
  t3p     = t3;
  t4p     = t4;
  t9      = mul(t3p,t2p);
  t9p     = t9;
  t8      = mul(t4p,t1p);
  w1      = t8;
  w1      = add(w1,t9p);

  t8      = sub(t8,t9p);
  x3p     = w1;
  z3p     = t8;
  w2      = square(x3p);
  x3p     = w2;
  w3      = square(z3p);
  z3p     = w3;
  w4      = mul(z3p,x1p);
  z3p     = w4;
  w5      = mul(t6p,t7p);
  x2p     = w5;
  w6      = mul(t5p,c121666p);
  w6      = add(w6,t7p);
  z2p     = w6;
  w7      = mul(z2p,t5p);
  z2p     = w7;

  return x2p, z2p, x3p, z3p;
}

// ** ladderstep (tracing version for debugging)
// ************************************************************************


fn ladderstep_tracing(
    stack x1p, x2p, z2p, x3p, z3p : u64[4]
  ) -> stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] *
       stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] *
       stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] *
       stack u64[4] * stack u64[4] * stack u64[4]
 {
  reg t1,  t2,  t7,  t6,  t5,  t3,  t4,  t9, t8  : u64[4];
  stack t1p, t2p, t7p, t6p, t5p, t3p, t4p, t9p : u64[4];
  reg w1, w2, w3, w4, w5, w6, w7 : u64[4];
  reg c121666p : u64[4];
  stack l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64[4];

  c121666p[0] = 121666;
  c121666p[1] = 0;
  c121666p[2] = 0;
  c121666p[3] = 0;

  // workp mapping: 0 -> x1p, 1 -> x2p, 2 -> z2p, 3 -> x3p, 4 -> z3p
  t1  = x2p;
  t2  = t1;
  t1  = add(t1,z2p);       l1 = t1;
  t2  = sub(t2,z2p);       l2 = t2;
  t1p = t1;
  t2p = t2;
  t7  = square(t2p);       l3 = t7;
  t7p = t7;
  t6  = square(t1p);       l4 = t6;
  t6p = t6;
  t5  = t6;
  t5  = sub(t5,t7p);       l5 = t5;
  t5p = t5;
  t3  = x3p;
  t4  = t3;
  t3  = add(t3,z3p);       l6 = t3;
  t4  = sub(t4,z3p);       l7 = t4;
  t3p = t3;
  t4p = t4;
  t9  = mul(t3p,t2p);      l8 = t9;
  t9p = t9;
  t8  = mul(t4p,t1p);      l9 = t8;
  w1  = t8;
  w1  = add(w1,t9p);       l10 = w1;

  t8  = sub(t8,t9p);       l11 = t8;
  x3p = w1;
  z3p = t8;
  w2  = square(x3p);       l12 = w2;
  x3p = w2;
  w3  = square(z3p);       l13 = w3;
  z3p = w3;
  w4  = mul(z3p,x1p);      l14 = w4;
  z3p = w4;
  w5  = mul(t6p,t7p);      l15 = w5;
  x2p = w5;
  w6  = mul(t5p,c121666p); l16 = w6;
  w6  = add(w6,t7p);       l17 = w6;
  z2p = w6;
  w7  = mul(z2p,t5p);      l18 = w7;
  z2p = w7;

  return l1,  l2, l3,   l4,  l5,
         l6,  l7, l8,   l9,  l10,
         l11, l12, l13, l14, l15,
         l16, l17, l18;
}

// ** cswap
// ************************************************************************

// FIXME: compare with OpenSSL, this is a translation from C
fn cswap(stack x2p, z2p, x3p, z3p : u64[4], stack swap : u64)
    -> stack u64[4] * stack u64[4] * stack u64[4] * stack u64[4] {
  reg tmp, mask : u64;
  inline i : u64;

  mask = swap * 0xffffffffffffffff;

  for i in 0..4 {
    tmp = x2p[i] ^ x3p[i];
    tmp = tmp & mask;
    x2p[i] = x2p[i] ^ tmp;
    x3p[i] = x3p[i] ^ tmp;

    tmp = z2p[i] ^ z3p[i];
    tmp = tmp & mask;
    z2p[i] = z2p[i] ^ tmp;
    z3p[i] = z3p[i] ^ tmp;
  }
  return x2p, z2p, x3p, z3p;
}


// ** montgomery ladder
// ************************************************************************

fn mladder(stack xr, sp : u64[4]) -> stack u64[4] * stack u64[4] {
  stack s : u64;
  reg   tmp : u64;
  stack prevbit, bit, swap : u64;
  stack x1,x2,z2,x3,z3 : u64[4];
  stack i, j : u64;

  prevbit = 0;
  x1 = xr;
  x2[0] = 1; x2[1] = 0; x2[2] = 0; x2[3] = 0;
  z2[0] = 0; z2[1] = 0; z2[2] = 0; z2[3] = 0;
  x3 = xr;
  z3[0] = 1; z3[1] = 0; z3[2] = 0; z3[3] = 0;

  for: i in 4..0 {
    tmp = sp[i];
    s = tmp;
    for: j in 64..0 {
      bit = s >> j;
      bit = bit & 1;
      swap = bit ^ prevbit;
      prevbit = bit;
      x2,z2,x3,z3 = cswap(x2,z2,x3,z3,swap);
      x2,z2,x3,z3 = ladderstep(x1,x2,z2,x3,z3);
    }
  }
  x2,z2,x3,z3 = cswap(x2,z2,x3,z3,prevbit);
  return x2, z2;
}

// ** inversion
// ************************************************************************

fn squarea(stack x : u64[4]) -> stack u64[4] {
  reg r : u64[4];
  stack ra : u64[4];
  r = square(x);
  ra = r;
  return ra;
}

fn mula(stack x, y : u64[4]) -> stack u64[4] {
  reg r : u64[4];
  stack ra : u64[4];
  r = mul(x,y);
  ra = r;
  return ra;
}

fn invert(stack xa : u64[4]) -> stack u64[4] {
  stack ra, z2, t, z9, x, z11, z2_5_0, z2_10_0, z2_20_0, z2_50_0 : u64[4];
  stack z2_100_0 : u64[4];
  inline i : u64;

  z2 = squarea(xa);                   /* 2 */
  t = squarea(z2);                    /* 4 */
  t = squarea(t);                     /* 8 */
  z9 = mula(t,xa);                    /* 9 */
  z11 = mula(z9,z2);                  /* 11 */
  t = squarea(z11);                   /* 22 */
  z2_5_0 = mula(t,z9);                /* 2^5 - 2^0 = 31 */

  t = squarea(z2_5_0);                /* 2^6 - 2^1 */
  for i in 1..5 { t = squarea(t); }   /* 2^20 - 2^10 */
  z2_10_0 = mula(t,z2_5_0);           /* 2^10 - 2^0 */

  t = squarea(z2_10_0);               /* 2^11 - 2^1 */
  for i in 1..10 { t = squarea(t); }  /* 2^20 - 2^10 */
  z2_20_0 = mula(t,z2_10_0);          /* 2^20 - 2^0 */

  t = squarea(z2_20_0);               /* 2^21 - 2^1 */
  for i in 1..20 { t = squarea(t); }  /* 2^40 - 2^20 */
  t = mula(t,z2_20_0);                /* 2^40 - 2^0 */

  t = squarea(t);                     /* 2^41 - 2^1 */
  for i in 1..10 { t = squarea(t); }  /* 2^50 - 2^10 */
  z2_50_0 = mula(t,z2_10_0);          /* 2^50 - 2^0 */

  t = squarea(z2_50_0);               /* 2^51 - 2^1 */
  for i in 1..50 { t = squarea(t); }  /* 2^100 - 2^50 */
  z2_100_0 = mula(t,z2_50_0);         /* 2^100 - 2^0 */

  t= squarea(z2_100_0);               /* 2^101 - 2^1 */
  for i in 1..100 { t = squarea(t); } /* 2^200 - 2^100 */
  t = mula(t,z2_100_0);               /* 2^200 - 2^0 */

  t = squarea(t);                     /* 2^201 - 2^1 */
  for i in 1..50 { t = squarea(t); }  /* 2^250 - 2^50 */
  t = mula(t,z2_50_0);                /* 2^250 - 2^0 */

  t = squarea(t);                     /* 2^251 - 2^1 */
  t = squarea(t);                     /* 2^252 - 2^2 */
  t = squarea(t);                     /* 2^253 - 2^3 */

  t = squarea(t);                     /* 2^254 - 2^4 */

  t = squarea(t);                     /* 2^255 - 2^5 */
  ra = mula(t,z11);                   /* 2^255 - 21 */

  return ra;
}

// ** unpack_point
// ************************************************************************

fn unpack_point(reg xp : u64) -> stack u64[4] {
  stack xa : u64[4];
  reg   x3 : u64;

  xa[0] = MEM[xp + 0*8];
  xa[1] = MEM[xp + 1*8];
  xa[2] = MEM[xp + 2*8];
  x3    = MEM[xp + 3*8];
  x3    = x3 & 9223372036854775807; // 0x7fffffffffffffff;
  xa[3] = x3;

  return xa;
}

// ** unpack_secret
// ************************************************************************

fn unpack_secret(reg sp : u64) -> stack u64[4] {
  stack sa : u64[4];
  reg   si : u64;

  si    = MEM[sp + 0*8];
  si    = si & 4722366482869645213688; // 0xfffffffffffffffff8;
  sa[0] = si;
  sa[1] = MEM[sp + 1*8];
  sa[2] = MEM[sp + 2*8];
  si    = MEM[sp + 3*8];
  si    = si & 9223372036854775807; // 0x7fffffffffffffffff;
  si    = si | 4611686018427387904; // FIXME: why does 0x400...0 not work
  sa[3] = si;
  return sa;
}

// ** freeze
// ************************************************************************

fn freeze(stack xa : u64[4]) -> stack u64[4] {
  reg r, t : u64[4];
  reg two63 : u64;
  flag cf : bool;

  r = xa;
  t = r;
  two63 = 1;
  two63 <<= 63;
  cf, t[0] += 19;
  cf, t[1] += 0     + cf;
  cf, t[2] += 0     + cf;
  cf, t[3] += two63 + cf;
  r[0] = t[0] if cf;
  r[1] = t[1] if cf;
  r[2] = t[2] if cf;
  r[3] = t[3] if cf;
  t[0] = r[0];
  t[1] = r[1];
  t[2] = r[2];
  t[3] = r[3];
  cf, t[0] += 19;
  cf, t[1] += 0     + cf;
  cf, t[2] += 0     + cf;
  cf, t[3] += two63 + cf;
  r[0] = t[0] if cf;
  r[1] = t[1] if cf;
  r[2] = t[2] if cf;
  r[3] = t[3] if cf;
  xa[0] = r[0];
  xa[1] = r[1];
  xa[2] = r[2];
  xa[3] = r[3];
  return xa;
}

// ** pack
// ************************************************************************

/* assumes input x reduced below 2^255 */
fn pack(reg rp : u64, stack xa : u64[4]) {
  inline i : u64;

  xa = freeze(xa);
  for i in 0..4 {
    MEM[rp + (i*8)] = xa[i];
  }
}

// ** scalar multiplication
// ************************************************************************

extern fn scalarmult( reg rp : u64 /* address to store result  */
                    , reg sp : u64 /* address of secret scalar */
                    , reg pp : u64 /* address of point         */) {
  stack sa, xa, za, zia : u64[4];
  reg   r : u64[4];

  sa = unpack_secret(sp);
  xa = unpack_point(pp);
  xa, za = mladder(xa,sa);
  zia = invert(za);
  r = mul(xa,zia);
  pack(rp,r);
}

fn scalarmult_tracing(
      reg rp : u64 /* address to store result  */
    , reg sp : u64 /* address of secret scalar */
    , reg pp : u64 /* address of point         */)
  -> stack u64[4] * stack u64[4] * stack u64[4] *
     stack u64[4] * stack u64[4] * stack u64[4]
{
  stack sa, xa, za, zia : u64[4];
  stack l1,l2,l3,l4,l5,l6 : u64[4];
  reg   r : u64[4];

  sa = unpack_secret(sp);       l1 = sa;
  xa = unpack_point(pp);        l2 = xa;
  xa, za = mladder(xa,sa);      l3 = xa; l4 = za;
  zia = invert(za);             l5 = zia;
  r = mul(xa,zia);              l6 =r;
  pack(rp,r);
  return l1,l2,l3,l4,l5,l6;
}

// * tests
// ************************************************************************

fn rand_arr(stack s : u64) -> stack u64[4] = python rand;
fn rand_point(stack s : u64) -> stack u64[4] = python rand_point;
fn assert_equal(stack x,y : u64[4]) = python assert_equal;
fn print_arr(stack x : u64[4]) = python print_u64_arr;
fn print_u64(stack x : u64) = python print_u64;
fn print_newline() = python print_newline;
fn assert_equal_add(stack x,y,z : u64[4]) = python assert_equal_add;
fn assert_equal_sub(stack x,y,z : u64[4]) = python assert_equal_sub;
fn assert_equal_mul(stack x,y,z : u64[4]) = python assert_equal_mul;
fn assert_equal_arr(stack x,y : u64[4]) = python assert_equal_arr;
fn assert_equal_ladderstep(stack x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r : u64[4])
  = python assert_equal_ladderstep;
fn assert_equal_ladderstep_tracing(stack x1,x2,z2,x3,z3
     ,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64[4])
  = python assert_equal_ladderstep_tracing;
fn assert_equal_mladder(stack xr, sp, xr_r, zr_r : u64[4]) = python assert_equal_mladder;
fn assert_equal_scalarmult(stack r, p, s : u64[4]) = python assert_equal_scalarmult;
fn assert_equal_scalarmult_tracing(stack r,p,s,l1,l2,l3,l4,l5,l6 : u64[4])
  = python assert_equal_scalarmult_tracing;
fn assert_equal_inv(stack x, y : u64[4]) = python assert_equal_inv;
fn mod_p(stack s : u64[4]) -> stack u64[4] = python mod_p;

fn test_add() {
  reg x, y_tmp, z : u64[4];
  stack y : u64[4];
  reg u : u64;
  inline i : u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    y = y_tmp;
    z = add(x,y);
    assert_equal_add(x,y,z);
  }
}

fn test_sub() {
  reg x, y_tmp, z : u64[4];
  stack y : u64[4];
  reg u : u64;
  inline i : u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    y = y_tmp;
    z = sub(x,y);
    assert_equal_sub(x,y,z);
  }
}

fn test_mul() {
  reg   x_tmp, y_tmp, z : u64[4];
  stack x, y : u64[4];
  reg   u : u64;
  inline i : u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x_tmp = rand_arr(u);
    u += 1;
    y_tmp = rand_arr(u);
    x = x_tmp;
    y = y_tmp;
    z = mul(x,y);
    assert_equal_mul(x,y,z);
  }
}

fn test_square() {
  reg   x_tmp, y_tmp, z : u64[4];
  stack x : u64[4];
  reg   u : u64;
  inline i : u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x_tmp = rand_arr(u);
    x = x_tmp;
    z = square(x);
    assert_equal_mul(x,x,z);
  }
}

fn test_ladderstep() {
  reg u : u64;
  reg x1, x2, z2, x3, z3 : u64[4];
  reg x2_r, z2_r, x3_r, z3_r : u64[4];
  inline i : u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x1 = rand_arr(u); u += 1;
    x2 = rand_arr(u); u += 1;
    z2 = rand_arr(u); u += 1;
    x3 = rand_arr(u); u += 1;
    z3 = rand_arr(u); u += 1;

    x2_r, z2_r, x3_r, z3_r = ladderstep(x1, x2, z2, x3, z3);
    assert_equal_ladderstep(x1,x2,z2,x3,z3,x2_r,z2_r,x3_r,z3_r);
  }
}

fn test_ladderstep_tracing() {
  reg u : u64;
  reg x1, x2, z2, x3, z3 : u64[4];
  reg x2_r, z2_r, x3_r, z3_r : u64[4];
  reg l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18 : u64[4];
  inline i : u64;

  for i in 0..999 {
    u = i;
    print_u64(u);
    x1 = rand_arr(u); u += 1;
    x2 = rand_arr(u); u += 1;
    z2 = rand_arr(u); u += 1;
    x3 = rand_arr(u); u += 1;
    z3 = rand_arr(u); u += 1;

    l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18
      = ladderstep_tracing(x1,x2,z2,x3,z3);
    assert_equal_ladderstep_tracing(x1, x2, z2, x3, z3,
      l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18);
  }
}

fn test_swap() {
  stack x2r, z2r, x3r, z3r : u64[4];
  stack x2r_a, z2r_a, x3r_a, z3r_a : u64[4];
  stack x2r_b, z2r_b, x3r_b, z3r_b : u64[4];
  stack u : u64;
  stack zero : u64;
  stack one  : u64;
  inline i : u64;

  zero = 0;
  one = 1;
  for i in 0..999 {
    u = i;
    print_u64(u);
    x2r = rand_arr(u); u += 1;
    z2r = rand_arr(u); u += 1;
    x3r = rand_arr(u); u += 1;
    z3r = rand_arr(u); u += 1;
    x2r_a, z2r_a, x3r_a, z3r_a = cswap(x2r,z2r,x3r,z3r,zero);
    x2r_b, z2r_b, x3r_b, z3r_b = cswap(x2r,z2r,x3r,z3r,one);

    assert_equal_arr(x2r, x2r_a);
    assert_equal_arr(z2r, z2r_a);
    assert_equal_arr(x3r, x3r_a);
    assert_equal_arr(z3r, z3r_a);

    assert_equal_arr(x2r, x3r_b);
    assert_equal_arr(z2r, z3r_b);
    assert_equal_arr(x3r, x2r_b);
    assert_equal_arr(z3r, z2r_b);
  }
}


fn test_mladder() {
  stack xr : u64[4];
  stack xr_r, zr_r : u64[4];
  stack sp     : u64[4];
  stack u : u64;
  inline i : u64;

  sp[0] = 0xffffffffffffffff;
  sp[1] = 0;
  sp[2] = 0x5555555555555555;
  sp[3] = 0xfffffffffffffffe;
  for i in 0..99 {
    u = i;
    print_u64(u);
    xr = rand_arr(u); u += 1;
    xr_r, zr_r = mladder(xr,sp);
    assert_equal_mladder(xr,sp,xr_r,zr_r);
  }
}

fn test_scalarmult() {
  stack pa, sa, ra : u64[4];
  reg rp, sp,pp : u64;
  stack u : u64;
  stack l1,l2,l3,l4,l5,l6 : u64[4];
  inline i : u64;

  rp = 0;
  sp = $(4*8); // 4*64bit = 4*8byte
  pp = $(8*8);

  for i in 0..99 {
    u = i;
    print_u64(u);
    pa = rand_point(u); u += 1;
    MEM[pp + 0*8] = pa[0];
    MEM[pp + 1*8] = pa[1];
    MEM[pp + 2*8] = pa[2];
    MEM[pp + 3*8] = pa[3];
    sa = rand_arr(u); u += 1;
    MEM[sp + 0*8] = sa[0];
    MEM[sp + 1*8] = sa[1];
    MEM[sp + 2*8] = sa[2];
    MEM[sp + 3*8] = sa[3];

    scalarmult(rp,sp,pp);
    //l1,l2,l3,l4,l5,l6 = scalarmult_tracing(rp,sp,pp);
    ra[0] = MEM[rp + 0*8];
    ra[1] = MEM[rp + 1*8];
    ra[2] = MEM[rp + 2*8];
    ra[3] = MEM[rp + 3*8];

    assert_equal_scalarmult(ra,pa,sa);
    //assert_equal_scalarmult_tracing(ra,pa,sa,l1,l2,l3,l4,l5,l6);
  }
}

fn test_full() {
  test_add();
  print_newline();
  test_sub();
  print_newline();
  test_mul();
  print_newline();
  test_square();
  print_newline();
  test_ladderstep_tracing();
  print_newline();
  test_ladderstep();
  print_newline();
  test_swap();
  print_newline();
  test_mladder();
  print_newline();
  test_scalarmult();
  print_newline();
}

fn test_fast() {
  test_mladder();
}

fn test() {
  test_full();
  print_newline();
}
