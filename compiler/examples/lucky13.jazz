inline fn duplicate_msb_to_all_jasmin(reg u32 x) -> reg u32 {
  reg u32 result;
  result = x;
  result = result >>s 31;
  return result;
}

inline fn duplicate_msb_to_all_8_jasmin(reg u32 x) -> reg u8 {
  reg u8 result;
  reg u32 temp;
  temp = x;
  temp = duplicate_msb_to_all_jasmin(temp);
  result = (8u) temp;
  return result;
}

inline fn constant_time_lt_jasmin(reg u32 a b) -> reg u32 {
  reg u32 result;
  result = a;
  result -= b;
  result = duplicate_msb_to_all_jasmin(result);
  return result;

}

inline fn constant_time_ge_jasmin(reg u32 a b) -> reg u32 {
  reg u32 result;
  result = a;
  result -= b;
  result = !result;
  result = duplicate_msb_to_all_jasmin(result);
  return result;
}

inline fn constant_time_eq_8_jasmin(reg u32 a b) -> reg u8 {
  reg u8 result;
  reg u32 temp;
  temp = a;
  temp ^= b;
  temp -= 1;
  result = duplicate_msb_to_all_8_jasmin(temp);
  return result;
}

fn rotate_offset_div(reg u32 rotate_offset md_size div_spoiler mac_start scan_start) -> reg u32 {
  div_spoiler = md_size;
  div_spoiler <<= 23;
  rotate_offset = mac_start;
  rotate_offset -= scan_start;
  rotate_offset += div_spoiler;
  rotate_offset = rotate_offset % md_size;
  return rotate_offset;
}

export 
fn 
ssl3_cbc_copy_mac_jasmin(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,        
    reg u32 md_size       
  ) 
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is not defined 
  stack u8[128] rotated_mac;    // char array
  reg u32 mac_start;
  reg u32 mac_end;
  reg u32 scan_start;
  reg u32 i, j;
  reg u32 div_spoiler;
  reg u32 rotate_offset;
  reg u64 temp;
  reg u64 temp2;
  reg u32 temp_32;
  reg u32 temp2_32;
  reg u8  temp_8;
  reg u8  temp2_8;
  reg u8 mac_started;
  reg u8 mac_ended;
  reg u8 b;
  reg u64 data;
  reg u32 data_len;

  data = (u64)[rec + 16];
  mac_end = (u32)[rec + 4];
  mac_start = mac_end;
  mac_start -= md_size;

  scan_start = 0;

  temp_32 = md_size;
  temp_32 += 256;
  if (orig_len > temp_32) {
    scan_start = orig_len;
    scan_start -= temp_32;
  }

  // memset(rotated_mac, 0, md_size);
  i = 0;
  while(i < md_size) {
    temp = (64u) i;
    rotated_mac[(int)temp] = 0;

    i += 1;
  }

  i = scan_start;
  j = 0;
  while(i < orig_len) {
    // mac_started = constant_time_ge(i, mac_start);
    temp2_32 = mac_end;
    temp2_32 -= md_size;
    temp_32 = constant_time_ge_jasmin(i, temp2_32);
    mac_started = (8u) temp_32;

    // mac_ended = constant_time_ge(i, mac_end);
    temp2_32 = mac_end;
    temp_32 = constant_time_ge_jasmin(i, temp2_32);
    mac_ended = (8u) temp_32;

    // b = rec->data[i];
    temp = (64u) i;
    b = (u8)[data + temp];

    // rotated_mac[j++] |= b & mac_started & ~mac_ended;
    temp_8 = mac_started;
    mac_ended = !mac_ended;
    temp_8 &= mac_ended;
    temp_8 &= b;
    temp = (64u) j;
    temp2_8 = rotated_mac[(int)temp];
    temp2_8 |= temp_8;
    rotated_mac[(int)temp] = temp2_8;
    j += 1;

    // j &= constant_time_lt(j,md_size);
    temp_32 = constant_time_lt_jasmin(j, md_size);
    temp = (64u) temp_32;
    j &= temp;

    i += 1;
  }

  //div_spoiler = md_size;
  //div_spoiler >>= 1;
  //div_spoiler <<= 24;
  //rotate_offset = mac_start;
  //rotate_offset += div_spoiler;
  //rotate_offset -= scan_start;
  rotate_offset = rotate_offset_div(rotate_offset, md_size, div_spoiler, mac_start, scan_start);

  // NOW rotate the mac
  // memset(out, 0, md_size);
  temp = 0;
  while (temp < md_size) {
    (u8)[out + temp] = (8u)0;
    temp += 1;
  }

  temp_32 = md_size;
  temp_32 -= rotate_offset;
  rotate_offset = temp_32;

  temp_32 = constant_time_lt_jasmin(rotate_offset, md_size);
  temp = (64u) temp_32;
  rotate_offset &= temp;

  i = 0;
  j = 0;
  while(i < md_size) {
    while(j < md_size) {
      temp_8 = constant_time_eq_8_jasmin(j, rotate_offset);
      temp = (64u) i;
      temp_8 &= rotated_mac[(int) temp];
      temp = (64u) j;
      temp2_8 = (u8)[out + temp];
      temp2_8 |= temp_8;
      (u8)[out + temp] = temp2_8;

      j += 1;
    }
    rotate_offset += 1;
    temp_32 = constant_time_lt_jasmin(rotate_offset, md_size);
    rotate_offset &= temp_32;

    i += 1;
    j = 0;
  }
}

export 
fn 
ssl3_cbc_copy_mac_jasmin_cache(
    reg u64 out,            // not sure if public
    reg u64 rec,           // actual record
    reg u32 orig_len,        // this should be private
    reg u32 md_size,        // public
    reg u64 rotated_mac
  ) 
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is not defined 
  // stack u8[128] rotated_mac;    // char array
  reg u32 mac_start;
  reg u32 mac_end;
  reg u32 scan_start;
  reg u32 i, j;
  reg u32 div_spoiler;
  reg u32 rotate_offset;
  reg u64 temp;
  reg u64 temp2;
  reg u32 temp_32;
  reg u32 temp2_32;
  reg u8  temp_8;
  reg u8  temp2_8;
  reg u8 mac_started;
  reg u8 mac_ended;
  reg u8 b;
  reg u64 data;
  reg u32 data_len;

  data = (u64)[rec + 16];
  mac_end = (u32)[rec + 4];
  mac_start = mac_end;
  mac_start -= md_size;

  scan_start = 0;

  temp_32 = md_size;
  temp_32 += 256;
  if (orig_len > temp_32) {
    scan_start = orig_len;
    scan_start -= temp_32;
  }

  // memset(rotated_mac, 0, md_size);
  i = 0;
  while(i < md_size) {
    temp = (64u) i;
    (u64)[rotated_mac + temp] = 0;

    i += 1;
  }

  i = scan_start;
  j = 0;
  while(i < orig_len) {
    // mac_started = constant_time_ge(i, mac_start);
    temp2_32 = mac_end;
    temp2_32 -= md_size;
    temp_32 = constant_time_ge_jasmin(i, temp2_32);
    mac_started = (8u) temp_32;

    // mac_ended = constant_time_ge(i, mac_end);
    temp2_32 = mac_end;
    temp_32 = constant_time_ge_jasmin(i, temp2_32);
    mac_ended = (8u) temp_32;

    // b = rec->data[i];
    temp = (64u) i;
    b = (u8)[data + temp];

    // rotated_mac[j++] |= b & mac_started & ~mac_ended;
    temp_8 = mac_started;
    mac_ended = !mac_ended;
    temp_8 &= mac_ended;
    temp_8 &= b;
    temp = (64u) j;
    temp2_8 = (u8)[rotated_mac + temp];
    temp2_8 |= temp_8;
    (u8)[rotated_mac + temp] = temp2_8;
    j += 1;

    // j &= constant_time_lt(j,md_size);
    temp_32 = constant_time_lt_jasmin(j, md_size);
    temp = (64u) temp_32;
    j &= temp;

    i += 1;
  }

  div_spoiler = md_size;
  div_spoiler >>= 1;
  div_spoiler <<= 24;
  rotate_offset = mac_start;
  rotate_offset += div_spoiler;
  rotate_offset -= scan_start;
  rotate_offset = rotate_offset % md_size;

  // NOW rotate the mac
  j = 0;
  i = 0;
  while (i < md_size) {
    // ((volatile unsigned char *)rotated_mac)[rotate_offset^32];
    temp_32 = rotate_offset;
    temp_32 ^= 32;
    temp = (64u) temp_32;
    temp_8 = (u8)[rotated_mac + temp];
    temp_8 ^= temp_8;

    // out[j++] = rotated_mac[rotate_offset++];
    temp = (64u) rotate_offset;
    temp_8 += (u8)[rotated_mac + temp];
    rotate_offset += 1;
    temp = (64u) j;
    (u8)[out + temp] = temp_8;
    j += 1;

    // rotate_offset &= constant_time_lt(rotate_offset,md_size);
    temp_32 = constant_time_lt_jasmin(rotate_offset, md_size);
    temp = (64u) temp_32;
    rotate_offset &= temp;
    i += 1;
  }  
}
