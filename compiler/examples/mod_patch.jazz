inline
fn lzcnt(reg u64 x) -> reg bool, reg u64 {
  reg u64 result;
  reg bool zf;
  _, _, _, _, zf, result = #LZCNT(x);
  return zf, result;
}

export fn verify_mod_const(reg u64 a, reg u64 b) -> reg u64 {
  reg u64 flag one zero dividend modulo result;
  reg u64 lzb lzb_m1 b_lzb b_lzb_m1 temp2;
  reg bool lzaz lzbz cf;

  flag = 0x1234;
  one = 1;
  zero = 0;

  lzbz, lzb = lzcnt(b);
  flag = zero if lzbz;
  lzaz, _ = lzcnt(a);
  flag = one if lzaz;

  lzb_m1 = #LEA(lzb - 1);
  b_lzb_m1 = b;
  b_lzb_m1 = b_lzb_m1 << lzb_m1;
  dividend = #LEA(b_lzb_m1 + a);

  b_lzb = b_lzb_m1 << 1;
  cf, temp2 = b_lzb + a;
  dividend = temp2 if !cf;

  dividend = a if flag == 1;
  temp2 = 0xFFFFFFFFFFFFFFFF;
  dividend = temp2 if flag == 0;  // lzb = 0 and lza ≠ 0,
                              // to leak big number if overflow happens
  modulo = dividend % b;
  result = modulo;
  result = a if flag == 0;    // lzb = 0 and lza ≠ 0
  return result;
}

