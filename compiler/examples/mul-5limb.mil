extern fn mul(zp, xp, yp0 /* rdx */) {

  yp = yp0;
  
  for i in 0 .. n {
    x[i] = *( xp + i*8);
    y[i] = *( yp + i*8);
  }

/* multiplication part */

  for i in 0 .. n {
    for j in 0 .. n {
      if i + j < n + 1 {
        (h,l) = x[i] * y[j];
        if i = 0 {
          r[i + j] = l;
	  m[i + j] = h;
        } else { 
          /*cf? r[i + j] += l; */
	  /*m[i + j] += h + cf;*/
	  }
      } else {
        x[i] = x[i] * 19;
	(h,l) = x[i] * y[j];
	cf? r[ i + j - n - 1] += l;
	m[ i + j - n - 1] += h + cf;
     
        }
    }
  } 


/* reduction part */
/* mask = 2^51 - 1 */	
  mask = 0; /* call constants FIXME */
				
  for i in 0 ..n {
    if i = 0 {
      m[0] <<= 13;
      mult = r[0];
      r[0] &= mask;
      mult >>= 51;
      m[0] ^= mult;
    } else {
      m[i] <<= 13;
      mult = r[i];
      r[i] &= mask;
      r[i] += m[i - 1];
      mult >>= 51;
      m[i] ^=mult;
      }
  }

  m[n] = m[n] * 19;
  r[0] += m[n];

  for i in 0 .. n {
    if i = 0 {
      mult = r[0];
      mult >>= 51;
      mult += r[1];
    } else {
      r[i] = mult;
      mult >>= 51;
      r[i - 1] &= mask;
      if i = n { 
        mult =  mult * 19;
	r[0] += mult;
	r[n] &= mask;  
      } else {
        mult += r[i + 1];
        }
      }
  }

  for i in 0 .. n {
    *( zp + i*8 ) = r[i];
  }
}