/* The implementation is parameterized by "n = limbs - 1". */
fn add<n : u64>(x : u64<n>, yp : u64[n]) {

  reg y : u64<n>;

  for i in 0..n {
    y<i> = yp[i];
    if (i = 0) {
      cf? x<0> += y<0>;
    } else {
      cf? x<i> += y<i> + cf;
    }
  }

  add0 = 0;
  add1 = 38;
  add1 = add0 if !cf;

  for i in  0..n {
    if (i = 0) {
      cf? x<0> += add1;
    } else {
      cf? x<i> += add0 + cf;
    }
  }

  add0 = add1 if cf;
  x<0> += add0;

  return x<0..n>;
}

extern fn add_call<n : u64>(zp, xp, yp : u64[n]) {
  reg x : u64<n>;
  for i in 0..n { x<i> = xp[i]; }
  x<0..n> =@ add(x<0..n>,yp);
  for i in 0..n { zp[i] = x<i>; }
}
