export fn test_lzcnt(reg u64 x) -> reg u64 {
  reg u64 result;
  _, _, _, _, _, result = #LZCNT(x);
  return result;
}

// Assuming that this works for u64 only and for a particular model
// below is non-constant-time
export fn verify_mod(reg u64 a b) -> reg u64 {
  reg u64 result;
  reg u64 lza;
  reg u64 lzb;
  reg u64 b_lzb;
  reg u64 b_lzb_1;
  reg u64 lzb_1;
  reg u64 temp;
  reg u64 res_temp;

  result = 0;

  _, _, _, _, _, lza = #LZCNT(a);
  _, _, _, _, _, lzb = #LZCNT(b);

  if (lza == 0) {
    res_temp = a;
    res_temp = res_temp % b;
    result = res_temp;
  } else {
    if (lzb == 0) {
      result = a;
    } else {
      b_lzb = b;
      b_lzb <<= lzb;
      temp = b_lzb + a;
      if (temp < b_lzb) {
        lzb_1 = lzb;
        lzb_1 -= 1;
        b_lzb_1 = b;
        b_lzb_1 <<= lzb_1;
        temp = b_lzb_1 + a;
        res_temp = temp % b;
        result = res_temp;
      } else {
        res_temp = temp % b;
        result = res_temp;
      }
    }
  }

  return result;
}


export fn verify_mod_const(reg u64 a, reg u64 b) -> reg u64 {
  reg u64 result;
  reg u64 lza;
  reg u64 lzb;
  reg u64 b_lzb;
  reg u64 b_lzb_1;
  reg u64 temp;
  reg u64 temp2;
  reg u64 temp3;
  reg u64 res_temp;
  reg u64 flag;
  reg u64 one;
  reg u64 zero;
  

  one = 1;
  zero = 0;
  _, _, _, _, _, lza = #LZCNT(a);
  _, _, _, _, _, lzb = #LZCNT(b);
  temp = a;
  flag = 0x1234;

  b_lzb = b;
  b_lzb <<= lzb;
  temp2 = b_lzb + a;
  temp = temp2;

  lzb -= 1;                   // lzb is reduced by 1
  b_lzb_1 = b;
  b_lzb_1 = b_lzb_1 << lzb;
  temp3 = b_lzb_1 + a;
  temp = temp3 if (temp2 < b_lzb);
  

  //_, _, _, _, _, lzb = #LZCNT(b);  // lzb value restored
  lzb += 1;   // this also works? check TODO
  temp = a if (lza == 0);
  // gonna be a common op
  // res_temp = temp % b;
  // result = res_temp;
  flag = zero if (lzb == 0);
  flag = one if (lza == 0);
  temp3 = 0xFFFFFFFFFFFFFFFF;
  res_temp = temp % b;
  result = res_temp;
  result = a if (flag == 0);    // lzb ==0 and lza != 0
  return result;
}
